<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> HTTP Response Smuggling / Desync | 47z!h4Ck </title> <meta name="author" content="47z!Lu7h "> <meta name="description" content=""> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://47z1lu7h.github.io/projects/pentesting-web/2025-01-01-http-response-smuggling-desync/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?0afe9f0ae161375728f7bcc5eb5b4ab4"></script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> 47z!h4Ck </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">h0m3 </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item active"> <a class="nav-link" href="/projects/">projects <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching </a> </li> <li class="nav-item "> <a class="nav-link" href="/people/">people </a> </li> <li class="nav-item "> <a class="nav-link" href="/hacking/">hacking </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/publications/">publications</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/projects/">projects</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">HTTP Response Smuggling / Desync</h1> <p class="post-description"></p> </header> <article> <h1 id="http-response-smuggling--desync">HTTP Response Smuggling / Desync</h1> <p><strong>The technique of this post was taken from the video:</strong> <a href="https://www.youtube.com/watch?v=suxDcYViwao&amp;t=1343s" rel="external nofollow noopener" target="_blank"><strong>https://www.youtube.com/watch?v=suxDcYViwao\&amp;t=1343s</strong></a></p> <h2 id="http-request-queue-desynchronisation">HTTP Request Queue Desynchronisation</h2> <p>First of all, this technique <strong>abuses a HTTP Request Smuggling vulnerability</strong>, so you need to know what that is:</p> <p>The <strong>main</strong> <strong>difference</strong> between this technique and a common HTTP Request smuggling is that <strong>instead</strong> of <strong>attacking</strong> the <strong>request</strong> of the <strong>victim</strong> <strong>by adding a prefix to it</strong>, we are going to <strong>leak or modify the response the victim receives</strong>. This is done by, instead of sending 1 request and a half to abuse the HTTP Request smuggling, <strong>send 2 complete requests to desynchronise the proxies responses queue</strong>.</p> <p>This is because we are going to be able to <strong>desynchronise the response queue</strong> so the <strong>response</strong> from the <strong>legit</strong> <strong>request</strong> of the <strong>victim is sent to the attacker</strong>, or by <strong>injecting attackers controlled content in the response to the victim</strong>.</p> <h3 id="http-pipeline-desync">HTTP Pipeline Desync</h3> <p>HTTP/1.1 allows to ask for <strong>different resources without needing to wait for previous ones</strong>. Therefore, if there is a <strong>proxy</strong> in the <strong>middle</strong>, it’s the proxies task to <strong>maintain a synchronised match of requests sent to the backend and responses coming from it</strong>.</p> <p>However, there is a problem desynchronising the responses queue. If an attacker send a HTTP Response smuggling attack and the responses to the <strong>initial request and the smuggled one are responded immediately</strong>, the smuggled response won’t be inserted inside the queue of the victim response but will <strong>just be discarded as an error</strong>.</p> <p><img src="../images/image%20(633).png" alt=""></p> <p>Therefore, it’s needed that the <strong>smuggled</strong> <strong>request</strong> <strong>takes more time to be processed</strong> inside the back-end server. Therefore, by the time the smuggled request is processed, the communication with the attacker will be over.</p> <p>If in this specific situation a <strong>victim has sent a request</strong> and the <strong>smuggled request is responded before</strong> the legitimate request, the <strong>smuggled response will be sent to the victim</strong>. Therefore, the attacker will be <strong>controlling the request “performed” by the victim</strong>.</p> <p>Moreover, is the <strong>attacker then perform a request</strong> and the <strong>legitimate response</strong> to the <strong>victim</strong> request is <strong>answered</strong> <strong>before</strong> the attackers request. The <strong>response to the victim is going to be sent to the attacker</strong>, <strong>stealing</strong> the response to the victim (which can contains for example the header <strong>Set-Cookie</strong>).</p> <p><img src="../images/image%20(1020).png" alt=""></p> <p><img src="../images/image%20(719).png" alt=""></p> <h3 id="multiple-nested-injections">Multiple Nested Injections</h3> <p>Another <strong>interesting difference</strong> with common <strong>HTTP Request Smuggling</strong> is that, in a common smuggling attack, the <strong>goal</strong> is to <strong>modify the beginning of the victims request</strong> so it perform an unexpected action. In a <strong>HTTP Response smuggling attack</strong>, as you are <strong>sending full requests</strong>, you can <strong>inject in one payload tens of responses</strong> that will be <strong>desynchronising tens of users</strong> that will be <strong>receiving</strong> the <strong>injected</strong> <strong>responses</strong>.</p> <p>Apart from being able to <strong>distribute more easily tens of exploits</strong> across legitimate users, this could also be used to cause a <strong>DoS</strong> in the server.</p> <h3 id="exploit-organisation">Exploit Organisation</h3> <p>As explained previously, in order to abuse this technique, it’s needed that the <strong>first smuggled message</strong> into the server <strong>requires a lot of time to be processed</strong>.</p> <p>This <strong>time consuming request is enough</strong> if we just want to <strong>try to steal the victims response.</strong> But if you want to perform a more complex exploit this will be a common structure for the exploit.</p> <p>First of all the <strong>initial</strong> request abusing <strong>HTTP</strong> <strong>Request</strong> <strong>smuggling</strong>, then the <strong>time consuming request</strong> and then <strong>1 or more payload requests</strong> that whose responses will be sent to the victims.</p> <h2 id="abusing-http-response-queue-desynchronisation">Abusing HTTP Response Queue Desynchronisation</h2> <h3 id="capturing-other-users-requests-">Capturing other users’ requests <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a> </h3> <p>As with HTTP Request Smuggling known payloads, you can <strong>steal the victims request</strong> with one important difference: In this case you just need the <strong>send content to be reflected in the response</strong>, <strong>no persistent storage</strong> is needed.</p> <p>First, the attacker send a payload containing a <strong>final POST request with the reflected parameter</strong> at the end and a large Content-Length</p> <p><img src="../images/image%20(1053).png" alt=""></p> <p>Then, once the <strong>initial request</strong> (blue) was <strong>processed</strong> and <strong>while</strong> the <strong>sleepy</strong> one is being processed (yellow) the <strong>next request that arrives from a victim</strong> is going to be <strong>appended in the queue just after the reflected parameter</strong>:</p> <p><img src="../images/image%20(794).png" alt=""></p> <p>Then, the <strong>victim</strong> will <strong>receive</strong> the <strong>response to the sleepy</strong> request and if in the meantime the <strong>attacker</strong> <strong>sent</strong> <strong>another</strong> <strong>request</strong>, the <strong>response from the reflected content request will be sent to him</strong>.</p> <h2 id="response-desynchronisation">Response Desynchronisation</h2> <p>Up to this point, we have learned how to abuse HTTP Request Smuggling attacks to <strong>control</strong> the <strong>request</strong> <strong>whose</strong> <strong>response</strong> a <strong>client</strong> is going to <strong>receive</strong> and how you can then <strong>steal the response that was meant for the victim</strong>.</p> <p>But it’s still possible to <strong>desynchronise even</strong> more the responses.</p> <p>There are interesting requests like <strong>HEAD</strong> request that are specified to not have <strong>any content inside the responses body</strong> and that should (must) <strong>contain the Content-Length</strong> of the request like <strong>if it was a GET request</strong>.</p> <p>Therefore, if an attacker <strong>injects</strong> a <strong>HEAD</strong> request, like in this images:</p> <p><img src="../images/image%20(1107).png" alt=""></p> <p>Then, <strong>once the blue one is responded to the attacker</strong>, the next victims request is going to be introduced in the queue:</p> <p><img src="../images/image%20(999).png" alt=""></p> <p>Then, the <strong>victim</strong> will <strong>receive</strong> the <strong>response</strong> from the <strong>HEAD</strong> request, which is <strong>going to contain a Content-Length but no content at all</strong>. Therefore, the proxy <strong>won’t send this response</strong> to the victim, but will <strong>wait</strong> for some <strong>content</strong>, which actually is going to be <strong>response to the yellow request</strong> (also injected by the attacker):</p> <p><img src="../images/image%20(735).png" alt=""></p> <h3 id="content-confusion">Content Confusion</h3> <p>Following the previous example, knowing that you can <strong>control the body</strong> of the request whose response is going to receive the victim and that a <strong>HEAD</strong> <strong>response</strong> usually contains in its headers the <strong>Content-Type and the Content-Length</strong>, you can <strong>send a request like the following</strong> one to <strong>cause XSS</strong> in the victim without the page being vulnerable to XSS:</p> <p><img src="../images/image%20(688).png" alt=""></p> <h3 id="cache-poisoning">Cache Poisoning</h3> <p>Abusing the previously commented response desynchronisation Content Confusion attack, i<strong>f the cache stores the response to the request performed by the victim and this response is an injected one causing a XSS, then the cache is poisoned</strong>.</p> <p>Malicious request containing the XSS payload:</p> <p><img src="../images/image%20(614).png" alt=""></p> <p>Malicious response to the victim that contains the header that indicates to the cache to store the response:</p> <p><img src="../images/image%20(566).png" alt=""></p> <blockquote> <p>[!WARNING] Note that in this case if the <strong>“victim” is the attacker</strong> he can now perform <strong>cache poisoning in arbitrary URLs</strong> as he can <strong>control the URL that is going to be cached</strong> with the malicious response.</p> </blockquote> <h3 id="web-cache-deception">Web Cache Deception</h3> <p>This attack is similar to the previous one, but <strong>instead of injecting a payload inside the cache, the attacker will be caching victim information inside of the cache:</strong></p> <p><img src="../images/image%20(991).png" alt=""></p> <h3 id="response-splitting">Response Splitting</h3> <p>The <strong>goal</strong> of this attack is to abuse again the <strong>response</strong> <strong>desynchronisation</strong> in order to <strong>make the proxy send a 100% attacker generated response</strong>.</p> <p>In order to achieve this, the attacker needs to find an endpoint of the web application that is <strong>reflecting some values inside the response</strong> and <strong>know the content length of the HEAD response</strong>.</p> <p>He will send a <strong>exploit</strong> like:</p> <p><img src="../images/image%20(911).png" alt=""></p> <p>After the first request is resolved and sent back to the attacker, the <strong>victims request is added into the queue</strong>:</p> <p><img src="../images/image%20(737).png" alt=""></p> <p>The victim will receive as response the <strong>HEAD response + the content of the second request response (containing part of the reflected data):</strong></p> <p><img src="../images/image%20(356).png" alt=""></p> <p>However, note how the <strong>reflected data had a size according to the Content-Length</strong> of the <strong>HEAD</strong> response that <strong>generated a valid HTTP response in the response queue</strong>.</p> <p>Therefore, the <strong>next request of the second victim</strong> will be <strong>receiving</strong> as <strong>response something completely crafted by the attacker</strong>. As the response is completely crafted by the attacker he can also <strong>make the proxy cache the response</strong>.</p> </article> </div> </div> </div> </div> <footer class="sticky-bottom mt-5" role="contentinfo"> <div class="container"> © Copyright 2025 47z!Lu7h . Love is life. And if you miss love, you miss life. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?4a129fbf39254905f505c7246e641eaf"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>